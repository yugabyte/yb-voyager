//go:build integration

/*
Copyright (c) YugabyteDB, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law oqr agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package tgtdb

import (
	"database/sql"
	"fmt"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/yugabyte/yb-voyager/yb-voyager/src/constants"
	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils"
	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils/sqlname"
	testutils "github.com/yugabyte/yb-voyager/yb-voyager/test/utils"
)

func TestOracleIdentityColumnsDisableEnableCycle(t *testing.T) {
	// Initialize connection pool used by the functions to be tested
	oracle := testOracleTarget.TargetDB.(*TargetOracleDB)
	err := oracle.InitConnPool()
	require.NoError(t, err)

	// Create test table with GENERATED ALWAYS AS IDENTITY column
	// Note: Oracle allows only one identity column per table (ORA-30669)
	testOracleTarget.ExecuteSqls(
		`CREATE TABLE TEST_TABLE1 (
			ID NUMBER GENERATED ALWAYS AS IDENTITY,
			DATA VARCHAR2(100)
		)`,
	)
	defer testOracleTarget.ExecuteSqls(
		`DROP TABLE TEST_TABLE1`,
	)

	db, dbErr := testOracleTarget.GetConnection()
	require.NoError(t, dbErr)

	// Get the schema name from the Oracle target configuration
	schemaName := oracle.tconf.Schema

	// Test complete disable/enable cycle: ALWAYS -> BY DEFAULT -> ALWAYS
	tableColumnsMap := createOracleTableToColumnsStructMap(schemaName, map[string][]string{
		"TEST_TABLE1": {"ID"},
	})

	// Step 1: Verify initial ALWAYS state
	tableTypes, err := getOracleIdentityColumnTypes(db, schemaName, "TEST_TABLE1", []string{"ID"})
	require.NoError(t, err)
	assert.Equal(t, constants.IDENTITY_GENERATION_ALWAYS, tableTypes["ID"])

	// Step 2: Disable identity columns (ALWAYS -> BY DEFAULT)
	err = oracle.DisableGeneratedAlwaysAsIdentityColumns(tableColumnsMap)
	assert.NoError(t, err)

	// Verify columns are now BY DEFAULT
	tableTypesDisabled, err := getOracleIdentityColumnTypes(db, schemaName, "TEST_TABLE1", []string{"ID"})
	require.NoError(t, err)
	assert.Equal(t, constants.IDENTITY_GENERATION_BY_DEFAULT, tableTypesDisabled["ID"])

	// Step 3: Enable identity columns (BY DEFAULT -> ALWAYS)
	err = oracle.EnableGeneratedAlwaysAsIdentityColumns(tableColumnsMap)
	assert.NoError(t, err)

	// Verify columns are back to ALWAYS
	tableTypesFinal, err := getOracleIdentityColumnTypes(db, schemaName, "TEST_TABLE1", []string{"ID"})
	require.NoError(t, err)
	assert.Equal(t, constants.IDENTITY_GENERATION_ALWAYS, tableTypesFinal["ID"])
}

func TestOracleGetIdentityColumnNamesForTables(t *testing.T) {
	// Create test tables with identity columns
	// Note: Oracle allows only one identity column per table (ORA-30669)
	testOracleTarget.ExecuteSqls(
		`CREATE TABLE test_always_table (
			id NUMBER GENERATED ALWAYS AS IDENTITY,
			data VARCHAR2(100)
		)`,
		`CREATE TABLE test_bydefault_table (
			id NUMBER GENERATED BY DEFAULT AS IDENTITY,
			data VARCHAR2(100)
		)`,
		`CREATE TABLE test_mixed_table1 (
			always_col NUMBER GENERATED ALWAYS AS IDENTITY,
			regular_col NUMBER,
			data VARCHAR2(100)
		)`,
		`CREATE TABLE test_mixed_table2 (
			bydefault_col NUMBER GENERATED BY DEFAULT AS IDENTITY,
			regular_col NUMBER,
			data VARCHAR2(100)
		)`,
		`CREATE TABLE test_no_identity_table (
			id NUMBER PRIMARY KEY,
			data VARCHAR2(100)
		)`,
	)
	defer testOracleTarget.ExecuteSqls(
		`DROP TABLE test_always_table`,
		`DROP TABLE test_bydefault_table`,
		`DROP TABLE test_mixed_table1`,
		`DROP TABLE test_mixed_table2`,
		`DROP TABLE test_no_identity_table`,
	)

	schemaName := testOracleTarget.GetConfig().Schema
	// Build table tuples list
	tableTuplesList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithTargetName(schemaName+".TEST_ALWAYS_TABLE", schemaName, ORACLE),
		testutils.CreateNameTupleWithTargetName(schemaName+".TEST_BYDEFAULT_TABLE", schemaName, ORACLE),
		testutils.CreateNameTupleWithTargetName(schemaName+".TEST_MIXED_TABLE1", schemaName, ORACLE),
		testutils.CreateNameTupleWithTargetName(schemaName+".TEST_MIXED_TABLE2", schemaName, ORACLE),
		testutils.CreateNameTupleWithTargetName(schemaName+".TEST_NO_IDENTITY_TABLE", schemaName, ORACLE),
	}

	// Expected results for ALWAYS identity columns
	expectedAlways := map[string][]string{
		"TEST_ALWAYS_TABLE": {"ID"},
		"TEST_MIXED_TABLE1": {"ALWAYS_COL"},
	}

	// Expected results for BY DEFAULT identity columns
	expectedByDefault := map[string][]string{
		"TEST_BYDEFAULT_TABLE": {"ID"},
		"TEST_MIXED_TABLE2":    {"BYDEFAULT_COL"},
	}

	// Test 1: Get ALWAYS identity columns
	tableColsStructMap, err := testOracleTarget.TargetDB.(*TargetOracleDB).GetIdentityColumnNamesForTables(tableTuplesList, constants.IDENTITY_GENERATION_ALWAYS)
	assert.NoError(t, err)

	// Verify ALWAYS results
	for _, tableTuple := range tableTuplesList {
		_, tableName := tableTuple.ForCatalogQuery()
		expectedCols, shouldExist := expectedAlways[tableName]
		actualCols, exists := tableColsStructMap.Get(tableTuple)

		if shouldExist {
			assert.True(t, exists, "Expected ALWAYS identity columns for table %s", tableName)
			testutils.AssertEqualStringSlices(t, expectedCols, actualCols)
		} else {
			assert.False(t, exists, "Expected no ALWAYS identity columns for table %s", tableName)
		}
	}

	// Test 2: Get BY DEFAULT identity columns
	tableColsStructMapByDefault, err := testOracleTarget.TargetDB.(*TargetOracleDB).GetIdentityColumnNamesForTables(tableTuplesList, constants.IDENTITY_GENERATION_BY_DEFAULT)
	assert.NoError(t, err)

	// Verify BY DEFAULT results
	for _, tableTuple := range tableTuplesList {
		_, tableName := tableTuple.ForCatalogQuery()
		expectedCols, shouldExist := expectedByDefault[tableName]
		actualCols, exists := tableColsStructMapByDefault.Get(tableTuple)

		if shouldExist {
			assert.True(t, exists, "Expected BY DEFAULT identity columns for table %s", tableName)
			testutils.AssertEqualStringSlices(t, expectedCols, actualCols)
		} else {
			assert.False(t, exists, "Expected no BY DEFAULT identity columns for table %s", tableName)
		}
	}
}

// ============================================================================
// Helper Functions
// ============================================================================

// Helper function to get identity column types from Oracle's ALL_TAB_IDENTITY_COLS
func getOracleIdentityColumnTypes(db *sql.DB, schemaName, tableName string, columnNames []string) (map[string]string, error) {
	quotedColumns := make([]string, len(columnNames))
	for i, col := range columnNames {
		quotedColumns[i] = fmt.Sprintf("'%s'", col)
	}

	query := fmt.Sprintf(`
		SELECT COLUMN_NAME, GENERATION_TYPE
		FROM ALL_TAB_IDENTITY_COLS
		WHERE OWNER = '%s' AND TABLE_NAME = '%s'
		AND COLUMN_NAME IN (%s)
		ORDER BY COLUMN_NAME
	`, schemaName, tableName, strings.Join(quotedColumns, ","))

	rows, err := db.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := make(map[string]string)
	for rows.Next() {
		var colName, generationType string
		err := rows.Scan(&colName, &generationType)
		if err != nil {
			return nil, err
		}
		result[colName] = generationType
	}
	return result, nil
}

// Helper function to create StructMap[NameTuple, []string] mapping Oracle table NameTuples to their identity column lists
func createOracleTableToColumnsStructMap(schemaName string, tables map[string][]string) *utils.StructMap[sqlname.NameTuple, []string] {
	tableColumnsMap := utils.NewStructMap[sqlname.NameTuple, []string]()
	for tableName, columns := range tables {
		objName := sqlname.NewObjectName(constants.ORACLE, schemaName, schemaName, tableName)
		tableNameTup := sqlname.NameTuple{
			CurrentName: objName,
			SourceName:  objName, // ForKey() method requires either SourceName or TargetName
		}
		tableColumnsMap.Put(tableNameTup, columns)
	}
	return tableColumnsMap
}
