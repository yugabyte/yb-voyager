\o redundant-indexes.csv
COPY (
    WITH ind_att AS (
        SELECT
            pg_idx.indrelid,
            pg_idx.indexrelid,
            nsp.nspname AS schemaname,
            tbl.relname AS tablename,
            idx.relname AS indexname,
            pg_idx.indexprs,
            pg_idx.indpred,
            unkeys.k AS key_position,
            COALESCE(coll.collname, 'default') AS collation_name,
            pg_get_indexdef(pg_idx.indexrelid, unkeys.k::int, true) AS index_key_def,
            CASE
                WHEN (unopts.indopt & 4) = 4 THEN 'HASH'
                ELSE (CASE WHEN (unopts.indopt & 1) = 1 THEN 'DESC' ELSE 'ASC' END) || 
                     (CASE WHEN (unopts.indopt & 2) = 2 THEN ' NULLS FIRST' ELSE ' NULLS LAST' END)
            END AS options
        FROM pg_index pg_idx
        CROSS JOIN LATERAL unnest(pg_idx.indkey) WITH ORDINALITY AS unkeys(indkey, k)
        LEFT OUTER JOIN LATERAL unnest(pg_idx.indoption) WITH ORDINALITY AS unopts(indopt, pos)
            ON unopts.pos = unkeys.k
        JOIN pg_class idx ON idx.oid = pg_idx.indexrelid
        JOIN pg_namespace nsp ON nsp.oid = idx.relnamespace
        JOIN pg_class tbl ON tbl.oid = pg_idx.indrelid
        LEFT JOIN pg_attribute idx_att
            ON idx_att.attrelid = pg_idx.indexrelid
           AND idx_att.attnum = unkeys.k
           AND idx_att.attnum > 0
           AND NOT idx_att.attisdropped
        LEFT JOIN pg_collation coll ON idx_att.attcollation = coll.oid
        JOIN pg_am am ON am.oid = idx.relam
    ),
    indexes AS (
        SELECT
            i.indrelid,
            i.indexrelid,
            n.nspname AS schema_name,
            t.relname AS table_name,
            irel.relname AS index_name,
            i.indisunique AS is_unique,
            i.indnkeyatts,
            i.indnatts,
            pg_get_expr(i.indpred, i.indrelid) AS partial_pred,
            am.amname AS access_method,
            i.nullsnotdistinct AS indnullsnotdistinct,
            ARRAY_AGG(ao.index_key_def ORDER BY ao.key_position) AS columns_expressions,
            ARRAY_AGG(ao.collation_name ORDER BY ao.key_position) AS colcollations,
            ARRAY_AGG(oc.opcname ORDER BY ao.key_position) AS operator_classes,
            ARRAY_AGG(ao.options ORDER BY ao.key_position) AS column_options,
            ARRAY_AGG(ao.index_key_def ORDER BY ao.key_position) AS all_columns,
            (ARRAY_AGG(ao.index_key_def ORDER BY ao.key_position))[1:i.indnkeyatts] AS key_columns,
            CASE
                WHEN i.indnkeyatts < i.indnatts
                THEN (ARRAY_AGG(ao.index_key_def ORDER BY ao.key_position))[(i.indnkeyatts+1):]
                ELSE ARRAY[]::text[]
            END AS included_columns
        FROM ind_att ao
        JOIN (SELECT *, (row_to_json(pg_index)->>'indnullsnotdistinct')::boolean AS nullsnotdistinct FROM pg_index) i
            ON i.indexrelid = ao.indexrelid
        JOIN pg_class irel ON irel.oid = i.indexrelid
        JOIN pg_namespace n ON n.oid = irel.relnamespace
        JOIN pg_class t ON t.oid = i.indrelid
        JOIN pg_am am ON am.oid = irel.relam
        LEFT OUTER JOIN LATERAL unnest(i.indclass) WITH ORDINALITY AS opcls(opc, pos)
            ON ao.key_position = pos
        LEFT OUTER JOIN pg_opclass oc ON oc.oid = opcls.opc
        WHERE ao.schemaname = ANY(ARRAY[string_to_array(:'schema_list', '|')])
        GROUP BY
            i.indrelid, i.indexrelid, n.nspname, t.relname, irel.relname,
            i.indisunique, i.indnkeyatts, i.indpred, am.amname, i.indnatts, i.nullsnotdistinct
    ),
    indexes_no_constraints AS (
        SELECT idx.*
        FROM indexes idx
        LEFT JOIN pg_constraint c
            ON c.conindid = (
                SELECT cc.oid
                FROM pg_class cc
                WHERE cc.relname = idx.index_name
                  AND cc.relnamespace = (
                      SELECT ns.oid FROM pg_namespace ns WHERE ns.nspname = idx.schema_name
                  )
            )
        WHERE c.conindid IS NULL
    )
    SELECT DISTINCT ON (redundant.schema_name, redundant.table_name, redundant.index_name)
        :'source_node_name' AS source_node,
        redundant.schema_name AS redundant_schema_name,
        redundant.table_name AS redundant_table_name,
        redundant.index_name AS redundant_index_name,
        existing.schema_name AS existing_schema_name,
        existing.table_name AS existing_table_name,
        existing.index_name AS existing_index_name,
        pg_get_indexdef(redundant.indexrelid) AS redundant_ddl,
        pg_get_indexdef(existing.indexrelid) AS existing_ddl
    FROM indexes_no_constraints redundant
    JOIN indexes existing
        ON redundant.schema_name = existing.schema_name
       AND redundant.table_name = existing.table_name
       AND redundant.index_name <> existing.index_name
       AND redundant.access_method = existing.access_method
       AND redundant.indnkeyatts <= existing.indnkeyatts
       AND (existing.partial_pred IS NULL AND redundant.partial_pred IS NULL)
       AND existing.operator_classes[1:redundant.indnkeyatts] = redundant.operator_classes[1:redundant.indnkeyatts]
       AND existing.colcollations[1:redundant.indnkeyatts] = redundant.colcollations[1:redundant.indnkeyatts]
       AND (SELECT bool_and(redundant.column_options[i] = existing.column_options[i]) 
            FROM generate_series(1, redundant.indnkeyatts) AS g(i))
       AND (existing.key_columns[1:redundant.indnkeyatts] = redundant.key_columns
            AND redundant.included_columns <@ existing.all_columns[(redundant.indnkeyatts+1):]
            AND ((redundant.is_unique AND existing.is_unique 
                  AND redundant.key_columns = existing.key_columns
                  AND (NOT redundant.indnullsnotdistinct OR existing.indnullsnotdistinct))
                 OR (NOT redundant.is_unique AND NOT existing.is_unique)
                 OR (NOT redundant.is_unique AND existing.is_unique)))
       AND NOT (redundant.key_columns = existing.key_columns
                AND redundant.included_columns = existing.included_columns
                AND redundant.is_unique = existing.is_unique
                AND redundant.indnullsnotdistinct = existing.indnullsnotdistinct
                AND redundant.index_name < existing.index_name)
    ORDER BY redundant.schema_name, redundant.table_name, redundant.index_name, existing.index_name
) TO STDOUT WITH CSV HEADER;
\o
