//go:build integration

/*
Copyright (c) YugabyteDB, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package srcdb

import (
	"fmt"
	"testing"

	"github.com/samber/lo"
	"gotest.tools/assert"

	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils/sqlname"
	testutils "github.com/yugabyte/yb-voyager/yb-voyager/test/utils"
)

func TestPostgresGetAllTableNames(t *testing.T) {
	testPostgresSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.foo (
		id INT PRIMARY KEY,
		name VARCHAR
	);`,
		`INSERT into test_schema.foo values (1, 'abc'), (2, 'xyz');`,
		`CREATE TABLE test_schema.bar (
		id INT PRIMARY KEY,
		name VARCHAR
	);`,
		`INSERT into test_schema.bar values (1, 'abc'), (2, 'xyz');`,
		`CREATE TABLE test_schema.non_pk1(
		id INT,
		name VARCHAR(255)
	);`)
	defer testPostgresSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	sqlname.SourceDBType = "postgresql"
	testPostgresSource.Source.Schema = "test_schema" // used in query of GetAllTableNames()

	// Test GetAllTableNames
	_ = testPostgresSource.DB().Connect()
	actualTables := testPostgresSource.DB().GetAllTableNames()
	expectedTables := []*sqlname.SourceName{
		sqlname.NewSourceName("test_schema", "foo"),
		sqlname.NewSourceName("test_schema", "bar"),
		sqlname.NewSourceName("test_schema", "non_pk1"),
	}
	assert.Equal(t, len(expectedTables), len(actualTables), "Expected number of tables to match")
	testutils.AssertEqualSourceNameSlices(t, expectedTables, actualTables)
}

func TestPGGetColumnToSequenceMap(t *testing.T) {

	testPostgresSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA IF NOT EXISTS public;`,

		`CREATE SCHEMA IF NOT EXISTS custom_schema;`,

		//-- 1. SERIAL column (implicit)
		`CREATE TABLE public.serial_table (
			id SERIAL PRIMARY KEY,
			name TEXT
		);`,

		//-- 2. BIGSERIAL column
		`CREATE TABLE public.bigserial_table (
			id BIGSERIAL PRIMARY KEY,
			description TEXT
		);`,

		//-- 3. IDENTITY columns (Generated Always)
		`CREATE TABLE public.identity_always_table (
			id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
			info TEXT
		);`,

		//-- 4. IDENTITY columns (Generated By Default)
		`CREATE TABLE public.identity_default_table (
			id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			comments TEXT
		);`,

		//-- 5. DEFAULT nextval() with a manually created seq
		`CREATE SEQUENCE public.manual_seq START 1000;`,

		`CREATE TABLE public.default_nextval_table (
			id BIGINT NOT NULL DEFAULT nextval('public.manual_seq'),
			value TEXT
		);`,

		//-- 6. Same as above but cross-schema
		`CREATE SEQUENCE custom_schema.cross_schema_seq;`,

		`CREATE TABLE public.cross_schema_default_seq_table (
			id BIGINT NOT NULL DEFAULT nextval('custom_schema.cross_schema_seq'),
			payload TEXT
		);`,

		//-- 7. A table with a manually owned by sequence (DEFAULT)
		`CREATE SEQUENCE public.manual_linked_seq;`,

		`CREATE TABLE public.manual_linked_table (
			id BIGINT NOT NULL,
			meta TEXT
		);`,
		`ALTER TABLE public.manual_linked_table ALTER COLUMN id SET DEFAULT nextval('public.manual_linked_seq');`,
		`ALTER SEQUENCE public.manual_linked_seq OWNED BY  public.manual_linked_table.id;`,

		//--8 table with manually owned sequence on text column
		`CREATE SEQUENCE custom_schema.user_code_seq
		START WITH 1
		INCREMENT BY 1;`,

		`CREATE OR REPLACE FUNCTION generate_user_code() RETURNS TEXT AS $$
		DECLARE
			new_code TEXT;
		BEGIN
			SELECT 'USR' || LPAD(nextval('custom_schema.user_code_seq')::TEXT, 4, '0') 
			INTO new_code;
			RETURN new_code;
		END;
		$$ LANGUAGE plpgsql;

		CREATE TABLE custom_schema.users (
			user_id int PRIMARY KEY,
			user_code TEXT UNIQUE,
			name TEXT
		);`,

		`ALTER TABLE ONLY custom_schema.users ALTER COLUMN user_code SET DEFAULT generate_user_code();`,

		`ALTER SEQUENCE custom_schema.user_code_seq OWNED BY custom_schema.users.user_code;`,

		//--9 normal sequences not attached to tables
		`CREATE SEQUENCE seq1_unattached;`,
		`CREATE SEQUENCE custom_schema.seq2_unattached;`,

		//--10 manually linked sequence to multiple columns
		`CREATE SEQUENCE public.manual_linked_seq_another ;`,

		`CREATE TABLE public.manual_linked_table_1 (
			id BIGINT NOT NULL,
			meta TEXT
		);`,
		`ALTER TABLE public.manual_linked_table_1 ALTER COLUMN id SET DEFAULT nextval('public.manual_linked_seq_another');`,

		`CREATE TABLE public.manual_linked_table_2 (
			id BIGINT NOT NULL,
			meta TEXT
		);`,
		`ALTER TABLE public.manual_linked_table_2 ALTER COLUMN id SET DEFAULT nextval('public.manual_linked_seq_another');`,
	)
	defer testPostgresSource.TestContainer.ExecuteSqls(
		`DROP TABLE  public.serial_table;`,
		`DROP TABLE  public.bigserial_table;`,
		`DROP TABLE  public.identity_always_table;`,
		`DROP TABLE  public.identity_default_table;`,
		`DROP TABLE  public.default_nextval_table;`,
		`DROP TABLE  public.cross_schema_default_seq_table;`,
		`DROP TABLE  public.manual_linked_table;`,
		`DROP TABLE  public.manual_linked_table_1;`,
		`DROP TABLE  public.manual_linked_table_2;`,
		`DROP SEQUENCE IF EXISTS public.manual_linked_seq_another;`,
		`DROP TABLE  custom_schema.users;`,
		`DROP SEQUENCE  public.seq1_unattached;`,
		`DROP SEQUENCE IF EXISTS custom_schema.user_code_seq;`,
		`DROP FUNCTION generate_user_code;`,
		`DROP SEQUENCE manual_seq;`,
		`DROP SCHEMA custom_schema CASCADE;`)

	sqlname.SourceDBType = "postgresql"
	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("public.serial_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.bigserial_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.identity_always_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.identity_default_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.default_nextval_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.cross_schema_default_seq_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("custom_schema.users", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table_1", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table_2", "public", testPostgresSource.DBType),
	}
	testPostgresSource.Source.Schema = "public|custom_schema"

	// Test GetColumnToSequenceMap
	_ = testPostgresSource.DB().Connect()
	defer testPostgresSource.DB().Disconnect()

	fmt.Print("----- Full table list case ----- \n")
	actualColumnToSequenceMap := testPostgresSource.DB().GetColumnToSequenceMap(tableList)
	expectedColumnToSequenceMap := map[string]string{
		"public.serial_table.id":                   `public."serial_table_id_seq"`,
		"public.bigserial_table.id":                `public."bigserial_table_id_seq"`,
		"public.identity_always_table.id":          `public."identity_always_table_id_seq"`,
		"public.identity_default_table.id":         `public."identity_default_table_id_seq"`,
		"public.default_nextval_table.id":          `public."manual_seq"`,
		"public.cross_schema_default_seq_table.id": `custom_schema."cross_schema_seq"`,
		"public.manual_linked_table.id":            `public."manual_linked_seq"`,
		"custom_schema.users.user_code":            `custom_schema."user_code_seq"`,
		"public.manual_linked_table_1.id":          `public."manual_linked_seq_another"`,
		"public.manual_linked_table_2.id":          `public."manual_linked_seq_another"`,
	}
	assert.Equal(t, len(lo.Keys(actualColumnToSequenceMap)), len(lo.Keys(expectedColumnToSequenceMap)), "Expected number of tables to match")
	//asssert key val
	for key, val := range actualColumnToSequenceMap {
		expectedVal, ok := expectedColumnToSequenceMap[key]
		assert.Equal(t, ok, true)
		assert.Equal(t, expectedVal, val)
	}
	fmt.Print("Full table list case completed!\n")

	//case with less tables
	tableList = []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("public.serial_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.bigserial_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.identity_always_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.cross_schema_default_seq_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table_1", "public", testPostgresSource.DBType),
	}
	testPostgresSource.Source.Schema = "public|custom_schema"

	// Test GetColumnToSequenceMap

	fmt.Print("----- Subset of table list case ----- \n")
	actualColumnToSequenceMap = testPostgresSource.DB().GetColumnToSequenceMap(tableList)
	expectedColumnToSequenceMap = map[string]string{
		"public.serial_table.id":                   `public."serial_table_id_seq"`,
		"public.bigserial_table.id":                `public."bigserial_table_id_seq"`,
		"public.identity_always_table.id":          `public."identity_always_table_id_seq"`,
		"public.cross_schema_default_seq_table.id": `custom_schema."cross_schema_seq"`,
		"public.manual_linked_table.id":            `public."manual_linked_seq"`,
		"public.manual_linked_table_1.id":          `public."manual_linked_seq_another"`,
	}
	assert.Equal(t, len(lo.Keys(actualColumnToSequenceMap)), len(lo.Keys(expectedColumnToSequenceMap)), "Expected number of tables to match")
	//asssert key val
	for key, val := range actualColumnToSequenceMap {
		expectedVal, ok := expectedColumnToSequenceMap[key]
		assert.Equal(t, ok, true)
		assert.Equal(t, expectedVal, val)
	}
	fmt.Print("Subset of table list case completed!\n")
}

func TestPostgresGetTableToUniqueKeyColumnsMap(t *testing.T) {
	testPostgresSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.unique_table (
            id SERIAL PRIMARY KEY,
            email VARCHAR(255) UNIQUE,
            phone VARCHAR(20) UNIQUE,
            address VARCHAR(255) UNIQUE
        );`,
		`INSERT INTO test_schema.unique_table (email, phone, address) VALUES
            ('john@example.com', '1234567890', '123 Elm Street'),
            ('jane@example.com', '0987654321', '456 Oak Avenue');`,
		`CREATE TABLE test_schema.another_unique_table (
            user_id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE,
            age INT
        );`,
		`CREATE UNIQUE INDEX idx_age ON test_schema.another_unique_table(age);`,
		`INSERT INTO test_schema.another_unique_table (username, age) VALUES
            ('user1', 30),
            ('user2', 40);`)
	defer testPostgresSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	testPostgresSource.Schema = "test_schema"

	uniqueTablesList := []sqlname.NameTuple{
		{CurrentName: sqlname.NewObjectName("postgresql", "test_schema", "test_schema", "unique_table")},
		{CurrentName: sqlname.NewObjectName("postgresql", "test_schema", "test_schema", "another_unique_table")},
	}

	// Test GetTableToUniqueKeyColumnsMap
	_ = testPostgresSource.DB().Connect()
	actualUniqKeys, err := testPostgresSource.DB().GetTableToUniqueKeyColumnsMap(uniqueTablesList)
	if err != nil {
		t.Fatalf("Error retrieving unique keys: %v", err)
	}

	expectedUniqKeys := map[string][]string{
		"test_schema.unique_table":         {"email", "phone", "address"},
		"test_schema.another_unique_table": {"username", "age"},
	}

	// Compare the maps by iterating over each table and asserting the columns list
	for table, expectedColumns := range expectedUniqKeys {
		actualColumns, exists := actualUniqKeys[table]
		if !exists {
			t.Errorf("Expected table %s not found in uniqueKeys", table)
		}

		testutils.AssertEqualStringSlices(t, expectedColumns, actualColumns)
	}
}

func TestPostgresGetNonPKTables(t *testing.T) {
	testPostgresSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.table1 (
		id SERIAL PRIMARY KEY,
		name VARCHAR(100)
	);`,
		`CREATE TABLE test_schema.table2 (
		id SERIAL PRIMARY KEY,
		email VARCHAR(100)
	);`,
		`CREATE TABLE test_schema.non_pk1(
		id INT,
		name VARCHAR(255)
	);`,
		`CREATE TABLE test_schema.non_pk2(
		id INT,
		name VARCHAR(255)
	);`)
	defer testPostgresSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)
	testPostgresSource.Schema = "test_schema"

	// Test GetNonPKTables
	_ = testPostgresSource.DB().Connect()
	actualTables, err := testPostgresSource.DB().GetNonPKTables()
	assert.NilError(t, err, "Expected nil but non nil error: %v", err)

	expectedTables := []string{`test_schema."non_pk2"`, `test_schema."non_pk1"`} // func returns table.Qualified.Quoted
	testutils.AssertEqualStringSlices(t, expectedTables, actualTables)
}
