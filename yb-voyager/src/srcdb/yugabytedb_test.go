//go:build integration

/*
Copyright (c) YugabyteDB, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package srcdb

import (
	"fmt"
	"testing"

	"github.com/samber/lo"
	"gotest.tools/assert"

	"github.com/yugabyte/yb-voyager/yb-voyager/src/constants"
	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils"
	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils/sqlname"
	testutils "github.com/yugabyte/yb-voyager/yb-voyager/test/utils"
)

func TestYugabyteGetAllTableNames(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.foo (
		id INT PRIMARY KEY,
		name VARCHAR
	);`,
		`INSERT into test_schema.foo values (1, 'abc'), (2, 'xyz');`,
		`CREATE TABLE test_schema.bar (
		id INT PRIMARY KEY,
		name VARCHAR
	);`,
		`INSERT into test_schema.bar values (1, 'abc'), (2, 'xyz');`,
		`CREATE TABLE test_schema.non_pk1(
		id INT,
		name VARCHAR(255)
	);`)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	sqlname.SourceDBType = "postgresql"
	testYugabyteDBSource.Source.Schema = "test_schema" // setting schema to look for tables in

	// Test GetAllTableNames
	actualTables := testYugabyteDBSource.DB().GetAllTableNames()
	expectedTables := []*sqlname.SourceName{
		sqlname.NewSourceName("test_schema", "foo"),
		sqlname.NewSourceName("test_schema", "bar"),
		sqlname.NewSourceName("test_schema", "non_pk1"),
	}
	assert.Equal(t, len(expectedTables), len(actualTables), "Expected number of tables to match")
	testutils.AssertEqualSourceNameSlices(t, expectedTables, actualTables)
}

func TestYugabyteGetColumnToSequenceMap(t *testing.T) {

	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA IF NOT EXISTS public;`,

		`CREATE SCHEMA IF NOT EXISTS custom_schema;`,

		//-- 1. SERIAL column (implicit)
		`CREATE TABLE public.serial_table (
			id SERIAL PRIMARY KEY,
			name TEXT
		);`,

		//-- 2. BIGSERIAL column
		`CREATE TABLE public.bigserial_table (
			id BIGSERIAL PRIMARY KEY,
			description TEXT
		);`,

		//-- 3. IDENTITY columns (Generated Always)
		`CREATE TABLE public.identity_always_table (
			id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
			info TEXT
		);`,

		//-- 4. IDENTITY columns (Generated By Default)
		`CREATE TABLE public.identity_default_table (
			id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			comments TEXT
		);`,

		//-- 5. DEFAULT nextval() with a manually created seq
		`CREATE SEQUENCE public.manual_seq START 1000;`,

		`CREATE TABLE public.default_nextval_table (
			id BIGINT NOT NULL DEFAULT nextval('public.manual_seq'),
			value TEXT
		);`,

		//-- 6. Same as above but cross-schema
		`CREATE SEQUENCE custom_schema.cross_schema_seq;`,

		`CREATE TABLE public.cross_schema_default_seq_table (
			id BIGINT NOT NULL DEFAULT nextval('custom_schema.cross_schema_seq'),
			payload TEXT
		);`,

		//-- 7. A table with a manually owned by sequence (DEFAULT)
		`CREATE SEQUENCE public.manual_linked_seq;`,

		`CREATE TABLE public.manual_linked_table (
			id BIGINT NOT NULL,
			meta TEXT
		);`,
		`ALTER TABLE public.manual_linked_table ALTER COLUMN id SET DEFAULT nextval('public.manual_linked_seq');`,
		`ALTER SEQUENCE public.manual_linked_seq OWNED BY  public.manual_linked_table.id;`,

		//--8 table with manually owned sequence on text column
		`CREATE SEQUENCE custom_schema.user_code_seq
		START WITH 1
		INCREMENT BY 1;`,

		`CREATE OR REPLACE FUNCTION generate_user_code() RETURNS TEXT AS $$
		DECLARE
			new_code TEXT;
		BEGIN
			SELECT 'USR' || LPAD(nextval('custom_schema.user_code_seq')::TEXT, 4, '0') 
			INTO new_code;
			RETURN new_code;
		END;
		$$ LANGUAGE plpgsql;

		CREATE TABLE custom_schema.users (
			user_id int PRIMARY KEY,
			user_code TEXT UNIQUE,
			name TEXT
		);`,

		`ALTER TABLE ONLY custom_schema.users ALTER COLUMN user_code SET DEFAULT generate_user_code();`,

		`ALTER SEQUENCE custom_schema.user_code_seq OWNED BY custom_schema.users.user_code;`,

		//--9 normal sequences not attached to tables
		`CREATE SEQUENCE seq1_unattached;`,
		`CREATE SEQUENCE custom_schema.seq2_unattached;`,

		//--10 manually linked sequence to multiple columns
		`CREATE SEQUENCE public.manual_linked_seq_another ;`,

		`CREATE TABLE public.manual_linked_table_1 (
			id BIGINT NOT NULL,
			meta TEXT
		);`,
		`ALTER TABLE public.manual_linked_table_1 ALTER COLUMN id SET DEFAULT nextval('public.manual_linked_seq_another');`,

		`CREATE TABLE public.manual_linked_table_2 (
			id BIGINT NOT NULL,
			meta TEXT
		);`,
		`ALTER TABLE public.manual_linked_table_2 ALTER COLUMN id SET DEFAULT nextval('public.manual_linked_seq_another');`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(
		`DROP TABLE  public.serial_table;`,
		`DROP TABLE  public.bigserial_table;`,
		`DROP TABLE  public.identity_always_table;`,
		`DROP TABLE  public.identity_default_table;`,
		`DROP TABLE  public.default_nextval_table;`,
		`DROP TABLE  public.cross_schema_default_seq_table;`,
		`DROP TABLE  public.manual_linked_table;`,
		`DROP TABLE  public.manual_linked_table_1;`,
		`DROP TABLE  public.manual_linked_table_2;`,
		`DROP SEQUENCE IF EXISTS public.manual_linked_seq_another;`,
		`DROP TABLE  custom_schema.users;`,
		`DROP SEQUENCE  public.seq1_unattached;`,
		`DROP SEQUENCE IF EXISTS custom_schema.user_code_seq;`,
		`DROP FUNCTION generate_user_code;`,
		`DROP SEQUENCE manual_seq;`,
		`DROP SCHEMA custom_schema CASCADE;`)

	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("public.serial_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.bigserial_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.identity_always_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.identity_default_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.default_nextval_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.cross_schema_default_seq_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("custom_schema.users", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table_1", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table_2", "public", testPostgresSource.DBType),
	}

	// Test GetColumnToSequenceMap
	fmt.Print("--- Full table list case ---- \n")
	actualColumnToSequenceMap := testYugabyteDBSource.DB().GetColumnToSequenceMap(tableList)
	expectedColumnToSequenceMap := map[string]string{
		"public.serial_table.id":                   `public."serial_table_id_seq"`,
		"public.bigserial_table.id":                `public."bigserial_table_id_seq"`,
		"public.identity_always_table.id":          `public."identity_always_table_id_seq"`,
		"public.identity_default_table.id":         `public."identity_default_table_id_seq"`,
		"public.default_nextval_table.id":          `public."manual_seq"`,
		"public.cross_schema_default_seq_table.id": `custom_schema."cross_schema_seq"`,
		"public.manual_linked_table.id":            `public."manual_linked_seq"`,
		"custom_schema.users.user_code":            `custom_schema."user_code_seq"`,
		"public.manual_linked_table_1.id":          `public."manual_linked_seq_another"`,
		"public.manual_linked_table_2.id":          `public."manual_linked_seq_another"`,
	}
	assert.Equal(t, len(lo.Keys(actualColumnToSequenceMap)), len(lo.Keys(expectedColumnToSequenceMap)), "Expected number of tables to match")
	//asssert key val
	for key, val := range actualColumnToSequenceMap {
		expectedVal, ok := expectedColumnToSequenceMap[key]
		assert.Equal(t, ok, true)
		assert.Equal(t, expectedVal, val)
	}
	fmt.Print("Full table list case completed!\n")
	//case with less tables
	tableList = []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("public.serial_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.bigserial_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.identity_always_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.cross_schema_default_seq_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table_1", "public", testPostgresSource.DBType),
	}
	testPostgresSource.Source.Schema = "public|custom_schema"

	// Test GetColumnToSequenceMap
	fmt.Print("----- Subset of table list case ----- \n")
	actualColumnToSequenceMap = testYugabyteDBSource.DB().GetColumnToSequenceMap(tableList)
	expectedColumnToSequenceMap = map[string]string{
		"public.serial_table.id":                   `public."serial_table_id_seq"`,
		"public.bigserial_table.id":                `public."bigserial_table_id_seq"`,
		"public.identity_always_table.id":          `public."identity_always_table_id_seq"`,
		"public.cross_schema_default_seq_table.id": `custom_schema."cross_schema_seq"`,
		"public.manual_linked_table.id":            `public."manual_linked_seq"`,
		"public.manual_linked_table_1.id":          `public."manual_linked_seq_another"`,
	}
	assert.Equal(t, len(lo.Keys(actualColumnToSequenceMap)), len(lo.Keys(expectedColumnToSequenceMap)), "Expected number of tables to match")
	//asssert key val
	for key, val := range actualColumnToSequenceMap {
		expectedVal, ok := expectedColumnToSequenceMap[key]
		assert.Equal(t, ok, true)
		assert.Equal(t, expectedVal, val)
	}
	fmt.Print("Subset of table list case completed!\n")
}

func TestYugabyteGetTableToUniqueKeyColumnsMap(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.unique_table (
            id SERIAL PRIMARY KEY,
            email VARCHAR(255) UNIQUE,
            phone VARCHAR(20) UNIQUE,
            address VARCHAR(255) UNIQUE
        );`,
		`INSERT INTO test_schema.unique_table (email, phone, address) VALUES
            ('john@example.com', '1234567890', '123 Elm Street'),
            ('jane@example.com', '0987654321', '456 Oak Avenue');`,
		`CREATE TABLE test_schema.another_unique_table (
            user_id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE,
            age INT
        );`,
		`CREATE UNIQUE INDEX idx_age ON test_schema.another_unique_table(age);`,
		`INSERT INTO test_schema.another_unique_table (username, age) VALUES
            ('user1', 30),
            ('user2', 40);`)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	uniqueTablesList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("test_schema.unique_table", "test_schema", "postgresql"),
		testutils.CreateNameTupleWithSourceName("test_schema.another_unique_table", "test_schema", "postgresql"),
	}

	// Test GetTableToUniqueKeyColumnsMap
	actualUniqKeys, err := testYugabyteDBSource.DB().GetTableToUniqueKeyColumnsMap(uniqueTablesList)
	if err != nil {
		t.Fatalf("Error retrieving unique keys: %v", err)
	}

	expectedUniqKeys := utils.NewStructMap[sqlname.NameTuple, []string]()
	expectedUniqKeys.Put(testutils.CreateNameTupleWithSourceName("test_schema.unique_table", "test_schema", "postgresql"), []string{"email", "phone", "address"})
	expectedUniqKeys.Put(testutils.CreateNameTupleWithSourceName("test_schema.another_unique_table", "test_schema", "postgresql"), []string{"username", "age"})

	// Compare the maps by iterating over each table and asserting the columns list
	expectedUniqKeys.IterKV(func(table sqlname.NameTuple, expectedColumns []string) (bool, error) {
		actualColumns, exists := actualUniqKeys.Get(table)
		if !exists {
			t.Errorf("Expected table %s not found in uniqueKeys", table)
		}

		testutils.AssertEqualStringSlices(t, expectedColumns, actualColumns)
		return true, nil
	})
}

func TestYugabyteGetNonPKTables(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.table1 (
		id SERIAL PRIMARY KEY,
		name VARCHAR(100)
	);`,
		`CREATE TABLE test_schema.table2 (
		id SERIAL PRIMARY KEY,
		email VARCHAR(100)
	);`,
		`CREATE TABLE test_schema.non_pk1(
		id INT,
		name VARCHAR(255)
	);`,
		`CREATE TABLE test_schema.non_pk2(
		id INT,
		name VARCHAR(255)
	);`)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)
	testYugabyteDBSource.Source.Schema = "test_schema" // setting schema to look for tables in

	// Test GetNonPKTables
	actualTables, err := testYugabyteDBSource.DB().GetNonPKTables()
	assert.NilError(t, err, "Expected nil but non nil error: %v", err)

	expectedTables := []string{`test_schema."non_pk2"`, `test_schema."non_pk1"`} // func returns table.Qualified.Quoted
	testutils.AssertEqualStringSlices(t, expectedTables, actualTables)
}

func TestYugabyteFilterEmptyTables(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.empty_table1 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.empty_table2 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.empty_table3 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.empty_table4 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.empty_table5 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.non_empty_table1 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`INSERT INTO test_schema.non_empty_table1 VALUES (1, 'data1'), (2, 'data2');`,
		`CREATE TABLE test_schema.non_empty_table2 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`INSERT INTO test_schema.non_empty_table2 VALUES (1, 'data1'), (2, 'data2');`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table1", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table2", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table3", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table4", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table5", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.non_empty_table1", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.non_empty_table2", "test_schema", constants.YUGABYTEDB),
	}

	// Test FilterEmptyTables
	nonEmptyTables, emptyTables := testYugabyteDBSource.DB().FilterEmptyTables(tableList)

	// Assert non-empty tables
	expectedNonEmptyTables := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("test_schema.non_empty_table1", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.non_empty_table2", "test_schema", constants.YUGABYTEDB),
	}
	testutils.AssertEqualNameTuplesSlice(t, expectedNonEmptyTables, nonEmptyTables)

	// Assert empty tables
	expectedEmptyTables := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table1", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table2", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table3", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table4", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table5", "test_schema", constants.YUGABYTEDB),
	}
	testutils.AssertEqualNameTuplesSlice(t, expectedEmptyTables, emptyTables)
}

func TestYugabyteGetAllTableColumnsInfo(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,

		`CREATE TABLE test_schema.products (
			id SERIAL PRIMARY KEY,
			name VARCHAR(100) NOT NULL,
			price NUMERIC(10, 2),
			in_stock BOOLEAN,
			created_at TIMESTAMP DEFAULT NOW()
		);`,

		`CREATE TABLE test_schema.orders (
			order_id BIGINT PRIMARY KEY,
			customer_id INT,
			total DECIMAL(12, 2)
		);`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	ybDB := testYugabyteDBSource.DB().(*YugabyteDB)

	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("test_schema.products", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.orders", "test_schema", constants.YUGABYTEDB),
	}

	allColumnsInfo, err := getAllTableColumnsInfo(tableList, ybDB.db)
	assert.NilError(t, err, "Expected no error fetching table columns")
	assert.Equal(t, 2, len(allColumnsInfo), "Expected column info for 2 tables")

	// Verify products table columns and data types
	productsTable := tableList[0]
	productsInfo, exists := allColumnsInfo[productsTable]
	assert.Equal(t, true, exists, "Expected products table in results")
	assert.Equal(t, 5, len(productsInfo.Columns), "Expected 5 columns in products table")
	assert.Equal(t, 5, len(productsInfo.DataTypes), "Expected 5 data types in products table")

	// Verify column order matches table definition (ORDER BY attnum)
	testutils.AssertEqualStringSlices(t, []string{"id", "name", "price", "in_stock", "created_at"}, productsInfo.Columns)
	// Verify parallel arrays are aligned (columns[i] matches dataTypes[i])
	assert.Equal(t, "int4", productsInfo.DataTypes[0], "id should be int4")
	assert.Equal(t, "varchar", productsInfo.DataTypes[1], "name should be varchar")
	assert.Equal(t, "numeric", productsInfo.DataTypes[2], "price should be numeric")

	// Verify orders table
	ordersTable := tableList[1]
	ordersInfo, exists := allColumnsInfo[ordersTable]
	assert.Equal(t, true, exists, "Expected orders table in results")
	testutils.AssertEqualStringSlices(t, []string{"order_id", "customer_id", "total"}, ordersInfo.Columns)

	// Test edge case: Empty table list
	emptyResult, err := getAllTableColumnsInfo([]sqlname.NameTuple{}, ybDB.db)
	assert.NilError(t, err, "Expected no error for empty table list")
	assert.Equal(t, 0, len(emptyResult), "Expected empty result for empty table list")
}

func TestYugabyteFilterUnsupportedUserDefinedDatatypes(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA hr;`,
		`CREATE SCHEMA inventory;`,

		// Create composite types (UDTs) - these SHOULD be detected
		`CREATE TYPE hr.contact AS (
			phone VARCHAR,
			email VARCHAR
		);`,
		`CREATE TYPE inventory.device_specs AS (
			cpu VARCHAR,
			ram INT
		);`,

		// Create ENUM and DOMAIN types - these should NOT be detected
		`CREATE TYPE hr.status_enum AS ENUM ('active', 'inactive', 'pending');`,
		`CREATE DOMAIN hr.positive_int AS INTEGER CHECK (VALUE > 0);`,

		// Case 1: Table with composite UDT from its own schema
		`CREATE TABLE hr.employees (
			id SERIAL PRIMARY KEY,
			name VARCHAR,
			contact_info hr.contact
		);`,

		// Case 2: Cross-schema usage - hr table using inventory composite UDT
		`CREATE TABLE hr.employee_devices (
			employee_id INT,
			device_details inventory.device_specs
		);`,

		// Case 3: Table with ENUM and DOMAIN (should NOT be detected as unsupported UDTs)
		`CREATE TABLE hr.projects (
			id INT PRIMARY KEY,
			name VARCHAR,
			status hr.status_enum,
			priority hr.positive_int
		);`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(
		`DROP SCHEMA hr CASCADE;`,
		`DROP SCHEMA inventory CASCADE;`,
	)

	// Test with all three tables
	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("hr.employees", "hr", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("hr.employee_devices", "hr", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("hr.projects", "hr", constants.YUGABYTEDB),
	}

	// Get the underlying YugabyteDB instance to access private method
	ybDB := testYugabyteDBSource.DB().(*YugabyteDB)
	actualUDTs := ybDB.filterUnsupportedUserDefinedDatatypes(tableList)

	// Expected: Only composite types (typtype='c'), NOT enums or domains
	// hr.status_enum and hr.positive_int should be excluded
	expectedUDTs := []string{
		"hr.contact",
		"inventory.device_specs",
	}

	assert.Equal(t, len(expectedUDTs), len(actualUDTs),
		"Expected %d UDTs but got %d", len(expectedUDTs), len(actualUDTs))
	testutils.AssertEqualStringSlices(t, expectedUDTs, actualUDTs)

	// Test edge case: Empty table list
	emptyTableList := []sqlname.NameTuple{}
	actualEmptyUDTs := ybDB.filterUnsupportedUserDefinedDatatypes(emptyTableList)
	assert.Equal(t, 0, len(actualEmptyUDTs), "Expected empty list for empty table list")
}

// TestYugabyteGetColumnsWithSupportedTypes_AllScenarios tests:
// 1. UDT columns (composite types) correctly identified as unsupported with qualified names (same-schema and cross-schema)
// 2. Extension types (hstore) in custom schemas matched against unqualified unsupported list
// 3. Case-insensitive matching (catalog returns lowercase, unsupported list has uppercase)
// 4. Connector type differences (GRPC vs Logical - TSVECTOR handling)
// 5. Mixed scenarios: UDT + extension type + ENUM + regular columns in same table
// 6. Cross-schema type usage (types from one schema used in tables in another schema)
// 7. Offline migration mode (all types supported)
func TestYugabyteGetColumnsWithSupportedTypes_AllScenarios(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA custom_ext;`,
		`CREATE SCHEMA hr;`,
		`CREATE SCHEMA inventory;`,

		`CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA custom_ext;`,

		// Create composite UDTs
		`CREATE TYPE hr.contact AS (
			phone VARCHAR,
			email VARCHAR
		);`,
		`CREATE TYPE inventory.device_specs AS (
			cpu VARCHAR,
			ram INT
		);`,
		// Create ENUM type (supported in all modes)
		`CREATE TYPE hr.status_enum AS ENUM ('active', 'inactive', 'pending');`,

		// Case 1: Extension type in custom schema
		// Tests that "custom_ext.hstore" from catalog matches "HSTORE" in unsupported list
		`CREATE TABLE custom_ext.ext_table (
			id SERIAL PRIMARY KEY,
			name VARCHAR,
			metadata custom_ext.hstore,
			description TEXT
		);`,

		// Case 2: Mixed - UDT + extension type + ENUM + regular columns
		// Tests both same-schema and cross-schema usage for UDTs: hr.contact and inventory.device_specs
		`CREATE TABLE hr.employee_devices (
			employee_id INT,
			device_name VARCHAR,
			contact_info hr.contact,
			device_details inventory.device_specs,
			settings custom_ext.hstore,
			status hr.status_enum,
			notes TEXT
		);`,

		// Case 3: TSVECTOR with mixed case columns (tests case sensitivity and GRPC unsupported type)
		`CREATE TABLE custom_ext."SearchTable" (
			"ID" INT PRIMARY KEY,
			"Content" TEXT,
			"SearchVector" TSVECTOR
		);`,

		// Case 4: All regular columns (baseline)
		`CREATE TABLE hr.projects (
			id INT PRIMARY KEY,
			name VARCHAR,
			budget NUMERIC
		);`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(
		`DROP SCHEMA custom_ext CASCADE;`,
		`DROP SCHEMA hr CASCADE;`,
		`DROP SCHEMA inventory CASCADE;`,
	)

	ybDB := testYugabyteDBSource.DB().(*YugabyteDB)
	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("custom_ext.ext_table", "custom_ext", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("hr.employee_devices", "hr", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("custom_ext.\"SearchTable\"", "custom_ext", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("hr.projects", "hr", constants.YUGABYTEDB),
	}

	// ========== Test 1: Logical Connector (TSVECTOR and HSTORE supported) ==========
	t.Run("LogicalConnector", func(t *testing.T) {
		ybDB.source.IsYBGrpcConnector = false
		supportedCols, unsupportedCols, err := ybDB.GetColumnsWithSupportedTypes(tableList, true, false)
		assert.NilError(t, err, "Expected no error")

		// Case 1: ext_table - hstore is SUPPORTED in logical connector
		extTable := tableList[0]
		supported, exists := supportedCols.Get(extTable)
		assert.Equal(t, true, exists, "Expected custom_ext.ext_table in supported map")
		testutils.AssertEqualStringSlices(t, []string{"*"}, supported)

		_, exists = unsupportedCols.Get(extTable)
		assert.Equal(t, false, exists, "Expected custom_ext.ext_table NOT in unsupported map")

		// Case 2: employee_devices - UDTs and hstore unsupported, ENUM supported
		// Tests same-schema UDT (hr.contact), cross-schema UDT (inventory.device_specs),
		// cross-schema extension (custom_ext.hstore), and same-schema ENUM (hr.status_enum)
		devicesTable := tableList[1]
		supported, exists = supportedCols.Get(devicesTable)
		assert.Equal(t, true, exists, "Expected hr.employee_devices in supported map")
		testutils.AssertEqualStringSlices(t, []string{"employee_id", "device_name", "settings", "status", "notes"}, supported)

		unsupported, exists := unsupportedCols.Get(devicesTable)
		assert.Equal(t, true, exists, "Expected hr.employee_devices in unsupported map")
		testutils.AssertEqualStringSlices(t, []string{"contact_info", "device_details"}, unsupported) // both UDTs

		// Case 3: SearchTable (mixed case) - TSVECTOR is SUPPORTED in logical mode, tests case sensitivity
		searchTable := tableList[2]
		supported, exists = supportedCols.Get(searchTable)
		assert.Equal(t, true, exists, "Expected custom_ext.SearchTable in supported map")
		testutils.AssertEqualStringSlices(t, []string{"*"}, supported) // All columns supported

		_, exists = unsupportedCols.Get(searchTable)
		assert.Equal(t, false, exists, "Expected custom_ext.SearchTable NOT in unsupported map")

		// Case 4: projects - all columns supported
		projectsTable := tableList[3]
		supported, exists = supportedCols.Get(projectsTable)
		assert.Equal(t, true, exists, "Expected hr.projects in supported map")
		testutils.AssertEqualStringSlices(t, []string{"*"}, supported)

		_, exists = unsupportedCols.Get(projectsTable)
		assert.Equal(t, false, exists, "Expected hr.projects NOT in unsupported map")
	})

	// ========== Test 2: GRPC Connector (TSVECTOR and HSTORE unsupported) ==========
	t.Run("GRPCConnector", func(t *testing.T) {
		ybDB.source.IsYBGrpcConnector = true
		supportedCols, unsupportedCols, err := ybDB.GetColumnsWithSupportedTypes(tableList, true, false)
		assert.NilError(t, err, "Expected no error")

		// Case 1: ext_table - hstore is UNSUPPORTED in GRPC connector
		extTable := tableList[0]
		supported, exists := supportedCols.Get(extTable)
		assert.Equal(t, true, exists, "Expected custom_ext.ext_table in supported map")
		testutils.AssertEqualStringSlices(t, []string{"id", "name", "description"}, supported)

		unsupported, exists := unsupportedCols.Get(extTable)
		assert.Equal(t, true, exists, "Expected custom_ext.ext_table in unsupported map")
		testutils.AssertEqualStringSlices(t, []string{"metadata"}, unsupported)

		// Case 2: employee_devices - UDTs and hstore both unsupported in GRPC mode
		devicesTable := tableList[1]
		supported, exists = supportedCols.Get(devicesTable)
		assert.Equal(t, true, exists, "Expected hr.employee_devices in supported map")
		testutils.AssertEqualStringSlices(t, []string{"employee_id", "device_name", "status", "notes"}, supported)

		unsupported, exists = unsupportedCols.Get(devicesTable)
		assert.Equal(t, true, exists, "Expected hr.employee_devices in unsupported map")
		testutils.AssertEqualStringSlices(t, []string{"contact_info", "device_details", "settings"}, unsupported)

		// Case 3: SearchTable (mixed case) - TSVECTOR is UNSUPPORTED in GRPC mode, tests case sensitivity
		searchTable := tableList[2]
		supported, exists = supportedCols.Get(searchTable)
		assert.Equal(t, true, exists, "Expected custom_ext.SearchTable in supported map")
		testutils.AssertEqualStringSlices(t, []string{"ID", "Content"}, supported) // Mixed case column names

		unsupported, exists = unsupportedCols.Get(searchTable)
		assert.Equal(t, true, exists, "Expected custom_ext.SearchTable in unsupported map")
		testutils.AssertEqualStringSlices(t, []string{"SearchVector"}, unsupported) // TSVECTOR unsupported in GRPC, mixed case
	})

	// ========== Test 3: Offline Migration (all types supported) ==========
	t.Run("OfflineMigration", func(t *testing.T) {
		supportedCols, unsupportedCols, err := ybDB.GetColumnsWithSupportedTypes(tableList, false, false)
		assert.NilError(t, err, "Expected no error")

		// In offline migration, all columns should be supported for all tables (empty maps returned)
		assert.Equal(t, 0, len(supportedCols.Keys()), "Expected empty supported map for offline migration")
		assert.Equal(t, 0, len(unsupportedCols.Keys()), "Expected empty unsupported map for offline migration")
	})
}
