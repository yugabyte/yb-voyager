//go:build integration

/*
Copyright (c) YugabyteDB, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package srcdb

import (
	"fmt"
	"testing"

	"github.com/samber/lo"
	"gotest.tools/assert"

	"github.com/yugabyte/yb-voyager/yb-voyager/src/constants"
	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils/sqlname"
	testutils "github.com/yugabyte/yb-voyager/yb-voyager/test/utils"
)

func TestYugabyteGetAllTableNames(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.foo (
		id INT PRIMARY KEY,
		name VARCHAR
	);`,
		`INSERT into test_schema.foo values (1, 'abc'), (2, 'xyz');`,
		`CREATE TABLE test_schema.bar (
		id INT PRIMARY KEY,
		name VARCHAR
	);`,
		`INSERT into test_schema.bar values (1, 'abc'), (2, 'xyz');`,
		`CREATE TABLE test_schema.non_pk1(
		id INT,
		name VARCHAR(255)
	);`)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	sqlname.SourceDBType = "postgresql"
	testYugabyteDBSource.Source.Schema = "test_schema" // setting schema to look for tables in

	// Test GetAllTableNames
	actualTables := testYugabyteDBSource.DB().GetAllTableNames()
	expectedTables := []*sqlname.SourceName{
		sqlname.NewSourceName("test_schema", "foo"),
		sqlname.NewSourceName("test_schema", "bar"),
		sqlname.NewSourceName("test_schema", "non_pk1"),
	}
	assert.Equal(t, len(expectedTables), len(actualTables), "Expected number of tables to match")
	testutils.AssertEqualSourceNameSlices(t, expectedTables, actualTables)
}

func TestYugabyteGetColumnToSequenceMap(t *testing.T) {

	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA IF NOT EXISTS public;`,

		`CREATE SCHEMA IF NOT EXISTS custom_schema;`,

		//-- 1. SERIAL column (implicit)
		`CREATE TABLE public.serial_table (
			id SERIAL PRIMARY KEY,
			name TEXT
		);`,

		//-- 2. BIGSERIAL column
		`CREATE TABLE public.bigserial_table (
			id BIGSERIAL PRIMARY KEY,
			description TEXT
		);`,

		//-- 3. IDENTITY columns (Generated Always)
		`CREATE TABLE public.identity_always_table (
			id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
			info TEXT
		);`,

		//-- 4. IDENTITY columns (Generated By Default)
		`CREATE TABLE public.identity_default_table (
			id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			comments TEXT
		);`,

		//-- 5. DEFAULT nextval() with a manually created seq
		`CREATE SEQUENCE public.manual_seq START 1000;`,

		`CREATE TABLE public.default_nextval_table (
			id BIGINT NOT NULL DEFAULT nextval('public.manual_seq'),
			value TEXT
		);`,

		//-- 6. Same as above but cross-schema
		`CREATE SEQUENCE custom_schema.cross_schema_seq;`,

		`CREATE TABLE public.cross_schema_default_seq_table (
			id BIGINT NOT NULL DEFAULT nextval('custom_schema.cross_schema_seq'),
			payload TEXT
		);`,

		//-- 7. A table with a manually owned by sequence (DEFAULT)
		`CREATE SEQUENCE public.manual_linked_seq;`,

		`CREATE TABLE public.manual_linked_table (
			id BIGINT NOT NULL,
			meta TEXT
		);`,
		`ALTER TABLE public.manual_linked_table ALTER COLUMN id SET DEFAULT nextval('public.manual_linked_seq');`,
		`ALTER SEQUENCE public.manual_linked_seq OWNED BY  public.manual_linked_table.id;`,

		//--8 table with manually owned sequence on text column
		`CREATE SEQUENCE custom_schema.user_code_seq
		START WITH 1
		INCREMENT BY 1;`,

		`CREATE OR REPLACE FUNCTION generate_user_code() RETURNS TEXT AS $$
		DECLARE
			new_code TEXT;
		BEGIN
			SELECT 'USR' || LPAD(nextval('custom_schema.user_code_seq')::TEXT, 4, '0') 
			INTO new_code;
			RETURN new_code;
		END;
		$$ LANGUAGE plpgsql;

		CREATE TABLE custom_schema.users (
			user_id int PRIMARY KEY,
			user_code TEXT UNIQUE,
			name TEXT
		);`,

		`ALTER TABLE ONLY custom_schema.users ALTER COLUMN user_code SET DEFAULT generate_user_code();`,

		`ALTER SEQUENCE custom_schema.user_code_seq OWNED BY custom_schema.users.user_code;`,

		//--9 normal sequences not attached to tables
		`CREATE SEQUENCE seq1_unattached;`,
		`CREATE SEQUENCE custom_schema.seq2_unattached;`,

		//--10 manually linked sequence to multiple columns
		`CREATE SEQUENCE public.manual_linked_seq_another ;`,

		`CREATE TABLE public.manual_linked_table_1 (
			id BIGINT NOT NULL,
			meta TEXT
		);`,
		`ALTER TABLE public.manual_linked_table_1 ALTER COLUMN id SET DEFAULT nextval('public.manual_linked_seq_another');`,

		`CREATE TABLE public.manual_linked_table_2 (
			id BIGINT NOT NULL,
			meta TEXT
		);`,
		`ALTER TABLE public.manual_linked_table_2 ALTER COLUMN id SET DEFAULT nextval('public.manual_linked_seq_another');`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(
		`DROP TABLE  public.serial_table;`,
		`DROP TABLE  public.bigserial_table;`,
		`DROP TABLE  public.identity_always_table;`,
		`DROP TABLE  public.identity_default_table;`,
		`DROP TABLE  public.default_nextval_table;`,
		`DROP TABLE  public.cross_schema_default_seq_table;`,
		`DROP TABLE  public.manual_linked_table;`,
		`DROP TABLE  public.manual_linked_table_1;`,
		`DROP TABLE  public.manual_linked_table_2;`,
		`DROP SEQUENCE IF EXISTS public.manual_linked_seq_another;`,
		`DROP TABLE  custom_schema.users;`,
		`DROP SEQUENCE  public.seq1_unattached;`,
		`DROP SEQUENCE IF EXISTS custom_schema.user_code_seq;`,
		`DROP FUNCTION generate_user_code;`,
		`DROP SEQUENCE manual_seq;`,
		`DROP SCHEMA custom_schema CASCADE;`)

	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("public.serial_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.bigserial_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.identity_always_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.identity_default_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.default_nextval_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.cross_schema_default_seq_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("custom_schema.users", "public", testYugabyteDBSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table_1", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table_2", "public", testPostgresSource.DBType),
	}

	// Test GetColumnToSequenceMap
	fmt.Print("--- Full table list case ---- \n")
	actualColumnToSequenceMap := testYugabyteDBSource.DB().GetColumnToSequenceMap(tableList)
	expectedColumnToSequenceMap := map[string]string{
		"public.serial_table.id":                   `public."serial_table_id_seq"`,
		"public.bigserial_table.id":                `public."bigserial_table_id_seq"`,
		"public.identity_always_table.id":          `public."identity_always_table_id_seq"`,
		"public.identity_default_table.id":         `public."identity_default_table_id_seq"`,
		"public.default_nextval_table.id":          `public."manual_seq"`,
		"public.cross_schema_default_seq_table.id": `custom_schema."cross_schema_seq"`,
		"public.manual_linked_table.id":            `public."manual_linked_seq"`,
		"custom_schema.users.user_code":            `custom_schema."user_code_seq"`,
		"public.manual_linked_table_1.id":          `public."manual_linked_seq_another"`,
		"public.manual_linked_table_2.id":          `public."manual_linked_seq_another"`,
	}
	assert.Equal(t, len(lo.Keys(actualColumnToSequenceMap)), len(lo.Keys(expectedColumnToSequenceMap)), "Expected number of tables to match")
	//asssert key val
	for key, val := range actualColumnToSequenceMap {
		expectedVal, ok := expectedColumnToSequenceMap[key]
		assert.Equal(t, ok, true)
		assert.Equal(t, expectedVal, val)
	}
	fmt.Print("Full table list case completed!\n")
	//case with less tables
	tableList = []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("public.serial_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.bigserial_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.identity_always_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.cross_schema_default_seq_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table", "public", testPostgresSource.DBType),
		testutils.CreateNameTupleWithSourceName("public.manual_linked_table_1", "public", testPostgresSource.DBType),
	}
	testPostgresSource.Source.Schema = "public|custom_schema"

	// Test GetColumnToSequenceMap
	fmt.Print("----- Subset of table list case ----- \n")
	actualColumnToSequenceMap = testYugabyteDBSource.DB().GetColumnToSequenceMap(tableList)
	expectedColumnToSequenceMap = map[string]string{
		"public.serial_table.id":                   `public."serial_table_id_seq"`,
		"public.bigserial_table.id":                `public."bigserial_table_id_seq"`,
		"public.identity_always_table.id":          `public."identity_always_table_id_seq"`,
		"public.cross_schema_default_seq_table.id": `custom_schema."cross_schema_seq"`,
		"public.manual_linked_table.id":            `public."manual_linked_seq"`,
		"public.manual_linked_table_1.id":          `public."manual_linked_seq_another"`,
	}
	assert.Equal(t, len(lo.Keys(actualColumnToSequenceMap)), len(lo.Keys(expectedColumnToSequenceMap)), "Expected number of tables to match")
	//asssert key val
	for key, val := range actualColumnToSequenceMap {
		expectedVal, ok := expectedColumnToSequenceMap[key]
		assert.Equal(t, ok, true)
		assert.Equal(t, expectedVal, val)
	}
	fmt.Print("Subset of table list case completed!\n")
}

func TestYugabyteGetTableToUniqueKeyColumnsMap(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.unique_table (
            id SERIAL PRIMARY KEY,
            email VARCHAR(255) UNIQUE,
            phone VARCHAR(20) UNIQUE,
            address VARCHAR(255) UNIQUE
        );`,
		`INSERT INTO test_schema.unique_table (email, phone, address) VALUES
            ('john@example.com', '1234567890', '123 Elm Street'),
            ('jane@example.com', '0987654321', '456 Oak Avenue');`,
		`CREATE TABLE test_schema.another_unique_table (
            user_id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE,
            age INT
        );`,
		`CREATE UNIQUE INDEX idx_age ON test_schema.another_unique_table(age);`,
		`INSERT INTO test_schema.another_unique_table (username, age) VALUES
            ('user1', 30),
            ('user2', 40);`)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	uniqueTablesList := []sqlname.NameTuple{
		{CurrentName: sqlname.NewObjectName("postgresql", "test_schema", "test_schema", "unique_table")},
		{CurrentName: sqlname.NewObjectName("postgresql", "test_schema", "test_schema", "another_unique_table")},
	}

	// Test GetTableToUniqueKeyColumnsMap
	actualUniqKeys, err := testYugabyteDBSource.DB().GetTableToUniqueKeyColumnsMap(uniqueTablesList)
	if err != nil {
		t.Fatalf("Error retrieving unique keys: %v", err)
	}

	expectedUniqKeys := map[string][]string{
		"test_schema.unique_table":         {"email", "phone", "address"},
		"test_schema.another_unique_table": {"username", "age"},
	}

	// Compare the maps by iterating over each table and asserting the columns list
	for table, expectedColumns := range expectedUniqKeys {
		actualColumns, exists := actualUniqKeys[table]
		if !exists {
			t.Errorf("Expected table %s not found in uniqueKeys", table)
		}

		testutils.AssertEqualStringSlices(t, expectedColumns, actualColumns)
	}
}

func TestYugabyteGetNonPKTables(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.table1 (
		id SERIAL PRIMARY KEY,
		name VARCHAR(100)
	);`,
		`CREATE TABLE test_schema.table2 (
		id SERIAL PRIMARY KEY,
		email VARCHAR(100)
	);`,
		`CREATE TABLE test_schema.non_pk1(
		id INT,
		name VARCHAR(255)
	);`,
		`CREATE TABLE test_schema.non_pk2(
		id INT,
		name VARCHAR(255)
	);`)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)
	testYugabyteDBSource.Source.Schema = "test_schema" // setting schema to look for tables in

	// Test GetNonPKTables
	actualTables, err := testYugabyteDBSource.DB().GetNonPKTables()
	assert.NilError(t, err, "Expected nil but non nil error: %v", err)

	expectedTables := []string{`test_schema."non_pk2"`, `test_schema."non_pk1"`} // func returns table.Qualified.Quoted
	testutils.AssertEqualStringSlices(t, expectedTables, actualTables)
}

func TestYugabyteFilterEmptyTables(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,
		`CREATE TABLE test_schema.empty_table1 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.empty_table2 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.empty_table3 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.empty_table4 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.empty_table5 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`CREATE TABLE test_schema.non_empty_table1 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`INSERT INTO test_schema.non_empty_table1 VALUES (1, 'data1'), (2, 'data2');`,
		`CREATE TABLE test_schema.non_empty_table2 (
			id INT PRIMARY KEY,
			name VARCHAR(100)
		);`,
		`INSERT INTO test_schema.non_empty_table2 VALUES (1, 'data1'), (2, 'data2');`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table1", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table2", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table3", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table4", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table5", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.non_empty_table1", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.non_empty_table2", "test_schema", constants.YUGABYTEDB),
	}

	// Test FilterEmptyTables
	nonEmptyTables, emptyTables := testYugabyteDBSource.DB().FilterEmptyTables(tableList)

	// Assert non-empty tables
	expectedNonEmptyTables := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("test_schema.non_empty_table1", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.non_empty_table2", "test_schema", constants.YUGABYTEDB),
	}
	testutils.AssertEqualNameTuplesSlice(t, expectedNonEmptyTables, nonEmptyTables)

	// Assert empty tables
	expectedEmptyTables := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table1", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table2", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table3", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table4", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.empty_table5", "test_schema", constants.YUGABYTEDB),
	}
	testutils.AssertEqualNameTuplesSlice(t, expectedEmptyTables, emptyTables)
}

func TestYugabyteGetAllTableColumnsInfo(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA test_schema;`,

		`CREATE TABLE test_schema.products (
			id SERIAL PRIMARY KEY,
			name VARCHAR(100) NOT NULL,
			price NUMERIC(10, 2),
			in_stock BOOLEAN,
			created_at TIMESTAMP DEFAULT NOW()
		);`,

		`CREATE TABLE test_schema.orders (
			order_id BIGINT PRIMARY KEY,
			customer_id INT,
			total DECIMAL(12, 2)
		);`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(`DROP SCHEMA test_schema CASCADE;`)

	ybDB := testYugabyteDBSource.DB().(*YugabyteDB)

	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("test_schema.products", "test_schema", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("test_schema.orders", "test_schema", constants.YUGABYTEDB),
	}

	allColumnsInfo, err := ybDB.getAllTableColumnsInfo(tableList)
	assert.NilError(t, err, "Expected no error fetching table columns")
	assert.Equal(t, 2, len(allColumnsInfo), "Expected column info for 2 tables")

	// Verify products table columns and data types
	productsTable := tableList[0]
	productsInfo, exists := allColumnsInfo[productsTable]
	assert.Equal(t, true, exists, "Expected products table in results")
	assert.Equal(t, 5, len(productsInfo.Columns), "Expected 5 columns in products table")
	assert.Equal(t, 5, len(productsInfo.DataTypes), "Expected 5 data types in products table")

	// Verify column order matches table definition (ORDER BY attnum)
	testutils.AssertEqualStringSlices(t, []string{"id", "name", "price", "in_stock", "created_at"}, productsInfo.Columns)
	// Verify parallel arrays are aligned (columns[i] matches dataTypes[i])
	assert.Equal(t, "int4", productsInfo.DataTypes[0], "id should be int4")
	assert.Equal(t, "varchar", productsInfo.DataTypes[1], "name should be varchar")
	assert.Equal(t, "numeric", productsInfo.DataTypes[2], "price should be numeric")

	// Verify orders table
	ordersTable := tableList[1]
	ordersInfo, exists := allColumnsInfo[ordersTable]
	assert.Equal(t, true, exists, "Expected orders table in results")
	testutils.AssertEqualStringSlices(t, []string{"order_id", "customer_id", "total"}, ordersInfo.Columns)

	// Test edge case: Empty table list
	emptyResult, err := ybDB.getAllTableColumnsInfo([]sqlname.NameTuple{})
	assert.NilError(t, err, "Expected no error for empty table list")
	assert.Equal(t, 0, len(emptyResult), "Expected empty result for empty table list")
}

func TestYugabyteFilterUnsupportedUserDefinedDatatypes(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA hr;`,
		`CREATE SCHEMA inventory;`,

		// Create composite types (UDTs) - these SHOULD be detected
		`CREATE TYPE hr.contact AS (
			phone VARCHAR,
			email VARCHAR
		);`,
		`CREATE TYPE inventory.device_specs AS (
			cpu VARCHAR,
			ram INT
		);`,

		// Create ENUM and DOMAIN types - these should NOT be detected
		`CREATE TYPE hr.status_enum AS ENUM ('active', 'inactive', 'pending');`,
		`CREATE DOMAIN hr.positive_int AS INTEGER CHECK (VALUE > 0);`,

		// Case 1: Table with composite UDT from its own schema
		`CREATE TABLE hr.employees (
			id SERIAL PRIMARY KEY,
			name VARCHAR,
			contact_info hr.contact
		);`,

		// Case 2: Cross-schema usage - hr table using inventory composite UDT
		`CREATE TABLE hr.employee_devices (
			employee_id INT,
			device_details inventory.device_specs
		);`,

		// Case 3: Table with ENUM and DOMAIN (should NOT be detected as unsupported UDTs)
		`CREATE TABLE hr.projects (
			id INT PRIMARY KEY,
			name VARCHAR,
			status hr.status_enum,
			priority hr.positive_int
		);`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(
		`DROP SCHEMA hr CASCADE;`,
		`DROP SCHEMA inventory CASCADE;`,
	)

	// Test with all three tables
	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("hr.employees", "hr", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("hr.employee_devices", "hr", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("hr.projects", "hr", constants.YUGABYTEDB),
	}

	// Get the underlying YugabyteDB instance to access private method
	ybDB := testYugabyteDBSource.DB().(*YugabyteDB)
	actualUDTs := ybDB.filterUnsupportedUserDefinedDatatypes(tableList)

	// Expected: Only composite types (typtype='c'), NOT enums or domains
	// hr.status_enum and hr.positive_int should be excluded
	expectedUDTs := []string{
		"hr.contact",
		"inventory.device_specs",
	}

	assert.Equal(t, len(expectedUDTs), len(actualUDTs),
		"Expected %d UDTs but got %d", len(expectedUDTs), len(actualUDTs))
	testutils.AssertEqualStringSlices(t, expectedUDTs, actualUDTs)

	// Test edge case: Empty table list
	emptyTableList := []sqlname.NameTuple{}
	actualEmptyUDTs := ybDB.filterUnsupportedUserDefinedDatatypes(emptyTableList)
	assert.Equal(t, 0, len(actualEmptyUDTs), "Expected empty list for empty table list")
}

// TestYugabyteGetColumnsWithSupportedTypes_UDT tests that UDT columns are correctly
// identified as unsupported when using Debezium/streaming.
// Verifies that getAllTableColumnsInfo returns qualified UDT names (e.g., "hr.contact") that
// match the qualified names from filterUnsupportedUserDefinedDatatypes(), enabling correct filtering.
func TestYugabyteGetColumnsWithSupportedTypes_UDT(t *testing.T) {
	testYugabyteDBSource.TestContainer.ExecuteSqls(
		`CREATE SCHEMA hr;`,
		`CREATE SCHEMA inventory;`,

		// Create composite types (UDTs)
		`CREATE TYPE hr.contact AS (
			phone VARCHAR,
			email VARCHAR
		);`,
		`CREATE TYPE inventory.device_specs AS (
			cpu VARCHAR,
			ram INT
		);`,

		// Create ENUM type
		`CREATE TYPE hr.status_enum AS ENUM ('active', 'inactive', 'pending');`,

		// Case 1: Table with composite UDT and regular columns
		`CREATE TABLE hr.employees (
			id SERIAL PRIMARY KEY,
			name VARCHAR,
			age INT,
			contact_info hr.contact,
			department VARCHAR
		);`,

		// Case 2: Cross-schema usage with multiple column types
		`CREATE TABLE hr.employee_devices (
			employee_id INT,
			device_name VARCHAR,
			device_details inventory.device_specs,
			status hr.status_enum
		);`,

		// Case 3: Table with only regular columns (no UDTs)
		`CREATE TABLE hr.projects (
			id INT PRIMARY KEY,
			name VARCHAR,
			budget NUMERIC
		);`,
	)
	defer testYugabyteDBSource.TestContainer.ExecuteSqls(
		`DROP SCHEMA hr CASCADE;`,
		`DROP SCHEMA inventory CASCADE;`,
	)

	ybDB := testYugabyteDBSource.DB().(*YugabyteDB)
	tableList := []sqlname.NameTuple{
		testutils.CreateNameTupleWithSourceName("hr.employees", "hr", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("hr.employee_devices", "hr", constants.YUGABYTEDB),
		testutils.CreateNameTupleWithSourceName("hr.projects", "hr", constants.YUGABYTEDB),
	}

	// Test with useDebezium=true (where UDTs are unsupported)
	supportedCols, unsupportedCols, err := ybDB.GetColumnsWithSupportedTypes(tableList, true, false)
	assert.NilError(t, err, "Expected no error")

	// hr.employees: contact_info should be unsupported, rest should be supported
	employeesTable := tableList[0]
	supported, exists := supportedCols.Get(employeesTable)
	assert.Equal(t, true, exists, "Expected hr.employees in supported columns map")
	testutils.AssertEqualStringSlices(t, []string{"id", "name", "age", "department"}, supported)

	unsupported, exists := unsupportedCols.Get(employeesTable)
	assert.Equal(t, true, exists, "Expected hr.employees in unsupported columns map")
	testutils.AssertEqualStringSlices(t, []string{"contact_info"}, unsupported) // contact_info is a UDT

	// hr.employee_devices: device_details should be unsupported
	devicesTable := tableList[1]
	supported, exists = supportedCols.Get(devicesTable)
	assert.Equal(t, true, exists, "Expected hr.employee_devices in supported columns map")
	testutils.AssertEqualStringSlices(t, []string{"employee_id", "device_name", "status"}, supported)

	unsupported, exists = unsupportedCols.Get(devicesTable)
	assert.Equal(t, true, exists, "Expected hr.employee_devices in unsupported columns map")
	testutils.AssertEqualStringSlices(t, []string{"device_details"}, unsupported)

	// hr.projects: all columns should be supported (no UDTs)
	projectsTable := tableList[2]
	supported, exists = supportedCols.Get(projectsTable)
	assert.Equal(t, true, exists, "Expected hr.projects in supported columns map")
	testutils.AssertEqualStringSlices(t, []string{"*"}, supported)

	_, exists = unsupportedCols.Get(projectsTable)
	assert.Equal(t, false, exists, "Expected hr.projects NOT in unsupported columns map")
}
