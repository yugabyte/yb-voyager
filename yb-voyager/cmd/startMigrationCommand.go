/*
Copyright (c) YugabyteDB, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cmd

import (
	"encoding/json"
	"fmt"
	"math"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/charmbracelet/huh"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils"
)

var startMigrationCmd = &cobra.Command{
	Use:   "start-migration",
	Short: "Set up target database and migration workflow",
	Long: `Set up target database connection and select migration workflow.

This command should be run after assess-migration has completed. It will:
  - Display the assessment summary
  - Prompt for target YugabyteDB connection details
  - Let you choose a migration workflow (offline, live, etc.)
  - Update the config file with the target and workflow settings`,

	Run: func(cmd *cobra.Command, args []string) {
		runStartMigration()
	},
}

var startMigrationConfigFile string
var targetConnStringFlag string
var migrationWorkflowFlag string

func init() {
	rootCmd.AddCommand(startMigrationCmd)
	startMigrationCmd.Flags().StringVarP(&startMigrationConfigFile, "config-file", "c", "",
		"path to the config file generated by 'yb-voyager init'")
	startMigrationCmd.MarkFlagRequired("config-file")
	startMigrationCmd.Flags().StringVar(&targetConnStringFlag, "target-db-connection-string", "",
		"target YugabyteDB connection string (e.g. postgresql://yugabyte:yugabyte@host:5433/dbname). If provided, skips the interactive prompt.")
	startMigrationCmd.Flags().StringVar(&migrationWorkflowFlag, "workflow", "",
		"migration workflow: offline, live, live-fall-back, live-fall-forward. If provided, skips the interactive prompt.")
}

func runStartMigration() {
	// Resolve config file path
	var err error
	startMigrationConfigFile, err = filepath.Abs(startMigrationConfigFile)
	if err != nil {
		utils.ErrExit("failed to resolve config file path: %v", err)
	}

	if !utils.FileOrFolderExists(startMigrationConfigFile) {
		utils.ErrExit("config file not found: %s\nRun 'yb-voyager init' first to create a migration project.", startMigrationConfigFile)
	}

	// Load config to read source details and export-dir
	v := viper.New()
	v.SetConfigType("yaml")
	v.SetConfigFile(startMigrationConfigFile)
	if err := v.ReadInConfig(); err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	exportDirPath := v.GetString("export-dir")
	if exportDirPath == "" {
		utils.ErrExit("export-dir not set in config file: %s", startMigrationConfigFile)
	}

	// ── Section 1: Assessment Summary ──
	sourceDBType := v.GetString("source.db-type")
	sourceHost := v.GetString("source.db-host")
	sourcePort := v.GetInt("source.db-port")
	sourceDBName := v.GetString("source.db-name")

	assessmentReportPath := filepath.Join(exportDirPath, "assessment", "reports",
		fmt.Sprintf("%s.json", ASSESSMENT_FILE_NAME))
	assessmentDone := utils.FileOrFolderExists(assessmentReportPath)

	printAssessmentSection(sourceDBType, sourceHost, sourcePort, sourceDBName, assessmentDone, assessmentReportPath)

	if !assessmentDone {
		var proceed bool
		err := huh.NewConfirm().
			Title("Assessment has not been run. Proceed anyway?").
			Value(&proceed).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
		if !proceed {
			fmt.Println()
			fmt.Println("  Run assessment first:")
			fmt.Println("  " + cmdStyle.Render(fmt.Sprintf("yb-voyager assess-migration --config-file %s", displayPath(startMigrationConfigFile))))
			fmt.Println()
			return
		}
	}

	// ── Section 1b: Source connection ──
	// Try connecting to source DB; prompt for connection string if it fails.
	// Updates the config file and re-reads viper if source details change.
	tryConnectOrPromptSource(v, startMigrationConfigFile)

	// ── Section 2: Target connection ──
	var targetParsed *parsedConnInfo
	if targetConnStringFlag != "" {
		targetParsed = parseAndValidateTarget(targetConnStringFlag)
	} else {
		var targetConnString string
		for {
			err := huh.NewInput().
				Title("Enter the connection string for your target YugabyteDB").
				Description("Format: postgresql://user:password@host:5433/dbname").
				Placeholder("postgresql://yugabyte:yugabyte@localhost:5433/yugabyte").
				Value(&targetConnString).
				Run()
			if err != nil {
				utils.ErrExit("prompt failed: %v", err)
			}

			targetConnString = strings.TrimSpace(targetConnString)
			if targetConnString == "" {
				fmt.Println(color.RedString("  Target connection string is required."))
				continue
			}

			var parseErr error
			targetParsed, parseErr = parsePostgresConnString(targetConnString)
			if parseErr != nil {
				fmt.Println(color.RedString("  ✗ Invalid connection string: %v", parseErr))
				fmt.Println()
				continue
			}

			if err := validatePostgresConnection(targetConnString); err != nil {
				fmt.Println(color.RedString("  ✗ Connection failed: %v", err))
				fmt.Println()

				var retry bool
				huh.NewConfirm().
					Title("Would you like to try again?").
					Value(&retry).
					Run()
				if !retry {
					utils.ErrExit("Target connection is required to proceed.")
				}
				continue
			}
			break
		}
	}

	// ── Section 3: Workflow selection ──
	var workflow string
	if migrationWorkflowFlag != "" {
		workflow = migrationWorkflowFlag
		validWorkflows := []string{"offline", "live", "live-fall-back", "live-fall-forward"}
		valid := false
		for _, w := range validWorkflows {
			if workflow == w {
				valid = true
				break
			}
		}
		if !valid {
			utils.ErrExit("invalid workflow %q. Must be one of: offline, live, live-fall-back, live-fall-forward", workflow)
		}
	} else {
		err = huh.NewSelect[string]().
			Title("Select your data migration workflow").
			Options(
				huh.NewOption("Offline — One-time snapshot; requires downtime", "offline"),
				huh.NewOption("Live — Minimal downtime using change data capture", "live"),
				huh.NewOption("Live with fall-back — Can switch back to source if needed", "live-fall-back"),
				huh.NewOption("Live with fall-forward — Can switch to a source-replica if needed", "live-fall-forward"),
			).
			Value(&workflow).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
	}

	// Update config file
	updateConfigWithTargetAndWorkflow(startMigrationConfigFile, v, targetParsed, workflow)

	// ── Section 4: Configuring Migration (progressive checkmarks) ──
	printConfiguringSection(targetParsed, workflow, startMigrationConfigFile)

	// ── Section 5: What's Next ──
	printStartMigrationNextSteps(startMigrationConfigFile, v, workflow)
}

// parseAndValidateTarget parses and validates a target connection string provided via flag.
func parseAndValidateTarget(connStr string) *parsedConnInfo {
	connStr = strings.TrimSpace(connStr)
	parsed, err := parsePostgresConnString(connStr)
	if err != nil {
		utils.ErrExit("Invalid target connection string: %v", err)
	}
	if err := validatePostgresConnection(connStr); err != nil {
		utils.ErrExit("Target connection failed: %v", err)
	}
	return parsed
}

// printAssessmentSection prints the "Start Migration" header with source + assessment summary.
func printAssessmentSection(dbType, host string, port int, dbName string, assessmentDone bool, assessmentReportPath string) {
	kw := 13
	indent := strings.Repeat(" ", kw+1) // indent for continuation lines under key-value pairs

	var lines []string

	if dbType != "" {
		lines = append(lines, formatKeyValue("Source:", fmt.Sprintf("%s @ %s:%d/%s", titleCase(dbType), host, port, dbName), kw))
	}

	if assessmentDone {
		lines = append(lines, formatKeyValue("Assessment:", successStyle.Render("✓ completed"), kw))
		sizingInfo := loadAssessmentSizing(assessmentReportPath)
		if sizingInfo != "" {
			lines = append(lines, indent+sizingInfo)
		}
		htmlReportPath := strings.TrimSuffix(assessmentReportPath, ".json") + ".html"
		lines = append(lines, indent+dimStyle.Render("Report: "+displayPath(htmlReportPath)))
	} else {
		lines = append(lines, formatKeyValue("Assessment:", warnStyle.Render("not yet run"), kw))
	}

	printSection("Assessment Summary", lines...)
	fmt.Println()
}

// printConfiguringSection prints progressive checkmarks for target + workflow configuration.
func printConfiguringSection(target *parsedConnInfo, workflow, configFilePath string) {
	fmt.Println()
	fmt.Println("  " + titleStyle.Render("Starting Migration"))
	fmt.Println("  " + ruleStyle.Render(strings.Repeat("─", ruleWidth)))

	targetLine := fmt.Sprintf("YugabyteDB @ %s:%d/%s", target.Host, target.Port, target.DBName)
	fmt.Println("  " + formatKeyValue("Target:", targetLine, 10))
	fmt.Println("  " + formatKeyValue("Workflow:", workflowDisplayName(workflow), 10))
	fmt.Println()

	steps := []string{
		successLine("Connected to target database"),
		successLine("Updated config  " + dimStyle.Render(displayPath(configFilePath))),
	}
	for _, step := range steps {
		time.Sleep(1 * time.Second)
		fmt.Println("  " + step)
	}
	time.Sleep(500 * time.Millisecond)
	fmt.Println()
	fmt.Println("  " + successStyle.Render("Done!"))
	fmt.Println()
}

// loadAssessmentSizing reads the assessment report and returns a short sizing summary string.
func loadAssessmentSizing(reportPath string) string {
	data, err := os.ReadFile(reportPath)
	if err != nil {
		return ""
	}
	var report AssessmentReport
	if err := json.Unmarshal(data, &report); err != nil {
		return ""
	}
	if report.Sizing == nil {
		return ""
	}
	sr := report.Sizing.SizingRecommendation
	result := fmt.Sprintf("%.0f nodes, %d vCPU / %d GB each recommended",
		math.Ceil(sr.NumNodes), sr.VCPUsPerInstance, sr.MemoryPerInstance)
	if report.Sizing.FailureReasoning != "" {
		result += " (" + report.Sizing.FailureReasoning + ")"
	}
	return result
}

// workflowDisplayName returns a human-readable name for a workflow identifier.
func workflowDisplayName(workflow string) string {
	switch workflow {
	case "offline":
		return "Offline (snapshot)"
	case "live":
		return "Live (CDC)"
	case "live-fall-back":
		return "Live with fall-back"
	case "live-fall-forward":
		return "Live with fall-forward"
	default:
		return titleCase(workflow)
	}
}

func updateConfigWithTargetAndWorkflow(configFilePath string, v *viper.Viper, target *parsedConnInfo, workflow string) {
	// Read the existing config file content
	data, err := os.ReadFile(configFilePath)
	if err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	content := string(data)

	// The config was generated from the offline-migration.yaml template which already has
	// target and export-data/import-data sections with placeholder values.
	// We do in-place replacements on those sections.

	// --- Target replacements ---
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-host: 127.0.0.1", fmt.Sprintf("db-host: %s", target.Host))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-port: 5433", fmt.Sprintf("db-port: %d", target.Port))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-name: yugabyte", fmt.Sprintf("db-name: %s", target.DBName))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-user: test_user", fmt.Sprintf("db-user: %s", target.User))
	if target.Password != "" {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"db-password: test_password", fmt.Sprintf("db-password: '%s'", strings.ReplaceAll(target.Password, "'", "''")))
	} else {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"  db-password: test_password", "  # db-password: <password>  # Or set TARGET_DB_PASSWORD env var")
	}

	// --- Workflow: for offline migration, the template already has the correct export-type ---
	// For non-offline workflows, we would need to change export-type and add extra sections.
	// For the POC, offline is the primary workflow.
	switch workflow {
	case "offline":
		// Template already has export-type: snapshot-only — nothing to change
	case "live", "live-fall-back", "live-fall-forward":
		// Change export-type from snapshot-only to snapshot-and-changes
		content = strings.Replace(content, "export-type: snapshot-only", "export-type: snapshot-and-changes", 1)
	}

	if err := os.WriteFile(configFilePath, []byte(content), 0644); err != nil {
		utils.ErrExit("failed to update config file: %v", err)
	}
}

func titleCase(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// tryConnectOrPromptSource attempts to connect to the source database using values
// from the config file. If the connection fails (or required fields are missing),
// it prompts the user for a connection string, validates it, updates the config
// file, and re-reads viper.
func tryConnectOrPromptSource(v *viper.Viper, configFilePath string) *parsedConnInfo {
	host := v.GetString("source.db-host")
	port := v.GetInt("source.db-port")
	user := v.GetString("source.db-user")
	password := v.GetString("source.db-password")
	dbName := v.GetString("source.db-name")
	schema := v.GetString("source.db-schema")

	// If required fields are present, try connecting
	if host != "" && user != "" && dbName != "" {
		if port == 0 {
			port = 5432
		}
		connStr := buildPostgresConnString(host, port, user, password, dbName)
		if err := validatePostgresConnection(connStr); err == nil {
			return &parsedConnInfo{
				Host:     host,
				Port:     port,
				User:     user,
				Password: password,
				DBName:   dbName,
				Schema:   schema,
			}
		}
		// Connection failed with explicit config values -- let the user know
		fmt.Println(color.YellowString("  Could not connect to source database (%s@%s:%d/%s).", user, host, port, dbName))
		fmt.Println()
	}
	// If fields are missing (generate-scripts / skip flow), go straight to the prompt

	// Prompt for connection string
	var connString string
	var parsed *parsedConnInfo
	for {
		err := huh.NewInput().
			Title("Enter your source PostgreSQL connection string").
			Description("Format: postgresql://user:password@host:port/dbname").
			Value(&connString).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}

		connString = strings.TrimSpace(connString)
		if connString == "" {
			fmt.Println(color.RedString("  Source connection string is required."))
			continue
		}

		var parseErr error
		parsed, parseErr = parsePostgresConnString(connString)
		if parseErr != nil {
			fmt.Println(color.RedString("  ✗ Invalid connection string: %v", parseErr))
			fmt.Println()
			continue
		}

		fmt.Printf("  Connecting to %s:%d...\n", parsed.Host, parsed.Port)
		if err := validatePostgresConnection(connString); err != nil {
			fmt.Println(color.RedString("  ✗ Connection failed: %v", err))
			fmt.Println()

			var retry bool
			huh.NewConfirm().
				Title("Would you like to try again?").
				Value(&retry).
				Run()
			if !retry {
				utils.ErrExit("Source connection is required to proceed.")
			}
			continue
		}

		fmt.Println(color.GreenString("  ✓ Connected to source database"))
		fmt.Println()
		break
	}

	// Update config file with real source details
	schemas := parsed.Schema
	if schemas == "" {
		schemas = "public"
	}
	updateConfigWithSource(configFilePath, &sourceConfig{
		DBType:   "postgresql",
		Host:     parsed.Host,
		Port:     parsed.Port,
		DBName:   parsed.DBName,
		User:     parsed.User,
		Password: parsed.Password,
		Schema:   schemas,
	})

	// Re-read config so the rest of the flow sees real values
	if err := v.ReadInConfig(); err != nil {
		utils.ErrExit("failed to re-read config file after source update: %v", err)
	}

	return parsed
}

// buildPostgresConnString constructs a postgresql:// connection string from individual components.
func buildPostgresConnString(host string, port int, user, password, dbName string) string {
	var userInfo string
	if password != "" {
		userInfo = fmt.Sprintf("%s:%s", user, password)
	} else {
		userInfo = user
	}
	return fmt.Sprintf("postgresql://%s@%s:%d/%s", userInfo, host, port, dbName)
}

// updateConfigWithSource updates the source connection fields in the config file.
// It handles both commented-out fields (from the generate-scripts/skip flow) and
// template default values.
func updateConfigWithSource(configFilePath string, src *sourceConfig) {
	data, err := os.ReadFile(configFilePath)
	if err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	content := string(data)

	content = replaceConfigValue(content, "db-type:", "postgresql", src.DBType)

	// Each field may be commented out (# db-host: ...) or have a template default (db-host: localhost).
	// Try the commented-out form first, then fall back to the template default.
	sourceReplacements := []struct {
		commentedOut string
		templateVal  string
		newVal       string
	}{
		{"  # db-host: localhost", "  db-host: localhost", fmt.Sprintf("  db-host: %s", src.Host)},
		{"  # db-port: 5432", "  db-port: 5432", fmt.Sprintf("  db-port: %d", src.Port)},
		{"  # db-name: <database-name>", "  db-name: test_db", fmt.Sprintf("  db-name: %s", src.DBName)},
		{"  # db-schema: public", "  db-schema: public", fmt.Sprintf("  db-schema: %s", src.Schema)},
		{"  # db-user: <username>", "  db-user: test_user", fmt.Sprintf("  db-user: %s", src.User)},
	}

	for _, r := range sourceReplacements {
		replaced := replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
			r.commentedOut, r.newVal)
		if replaced != content {
			content = replaced
		} else {
			content = replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
				r.templateVal, r.newVal)
		}
	}

	// Handle password
	if src.Password != "" {
		passwordVal := fmt.Sprintf("  db-password: '%s'", strings.ReplaceAll(src.Password, "'", "''"))
		replaced := replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
			"  # db-password: <password>  # Or set SOURCE_DB_PASSWORD env var", passwordVal)
		if replaced != content {
			content = replaced
		} else {
			content = replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
				"  db-password: test_password", passwordVal)
		}
	} else {
		content = replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
			"  db-password: test_password", "  # db-password: <password>  # Or set SOURCE_DB_PASSWORD env var")
	}

	if err := os.WriteFile(configFilePath, []byte(content), 0644); err != nil {
		utils.ErrExit("failed to update config file with source details: %v", err)
	}
}

func printStartMigrationNextSteps(configFilePath string, v *viper.Viper, workflow string) {
	var lines []string

	step := 1

	// Check if permissions need granting
	sourceDBType := v.GetString("source.db-type")
	if sourceDBType == "postgresql" && (workflow == "live" || workflow == "live-fall-back" || workflow == "live-fall-forward") {
		sourceHost := v.GetString("source.db-host")
		sourceDBName := v.GetString("source.db-name")
		sourceUser := v.GetString("source.db-user")

		lines = append(lines, fmt.Sprintf("%d. Grant permissions for live migration:", step))
		lines = append(lines, "")
		lines = append(lines, cmdStyle.Render(fmt.Sprintf("  psql -h %s -d %s -U %s \\\n    -f /opt/yb-voyager/guardrails-scripts/yb-voyager-pg-grant-migration-permissions.sql",
			sourceHost, sourceDBName, sourceUser)))
		lines = append(lines, "")
		step++
	}

	if step == 1 {
		lines = append(lines, "Export the schema from your source database:")
	} else {
		lines = append(lines, fmt.Sprintf("%d. Export schema:", step))
	}
	lines = append(lines, "")
	lines = append(lines, cmdStyle.Render(fmt.Sprintf("  yb-voyager export schema \\\n    --config-file %s",
		displayPath(configFilePath))))

	printSection("What's Next", lines...)
	fmt.Println()
}
