/*
Copyright (c) YugabyteDB, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cmd

import (
	"encoding/json"
	"fmt"
	"math"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/charmbracelet/huh"
	"github.com/fatih/color"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/yugabyte/yb-voyager/yb-voyager/src/cp/yugabyted"
	"github.com/yugabyte/yb-voyager/yb-voyager/src/metadb"
	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils"
)

var startMigrationCmd = &cobra.Command{
	Use:   "start-migration",
	Short: "Set up target database and migration workflow",
	Long: `Set up target database connection and select migration workflow.

This command can be invoked in two ways:

1. With --config-file: Use an existing config from a previous 'yb-voyager init' run.
2. With --migration-dir, --assessment-control-plane, and --migration-uuid: Bootstrap
   a new migration project by pulling assessment data from a shared control plane.
   This is useful when you don't have access to the original migration directory.

The command will:
  - Display the assessment summary
  - Prompt for target YugabyteDB connection details
  - Let you choose a migration workflow (offline, live, etc.)
  - Update the config file with the target and workflow settings`,

	Run: func(cmd *cobra.Command, args []string) {
		runStartMigration()
	},
}

var startMigrationConfigFile string
var targetConnStringFlag string
var migrationWorkflowFlag string

var startMigrationDir string
var startAssessmentControlPlane string
var startMigrationUUID string

func init() {
	rootCmd.AddCommand(startMigrationCmd)
	startMigrationCmd.Flags().StringVarP(&startMigrationConfigFile, "config-file", "c", "",
		"path to the config file generated by 'yb-voyager init'")
	startMigrationCmd.Flags().StringVar(&targetConnStringFlag, "target-db-connection-string", "",
		"target YugabyteDB connection string (e.g. postgresql://yugabyte:yugabyte@host:5433/dbname). If provided, skips the interactive prompt.")
	startMigrationCmd.Flags().StringVar(&migrationWorkflowFlag, "workflow", "",
		"migration workflow: offline, live, live-fall-back, live-fall-forward. If provided, skips the interactive prompt.")

	startMigrationCmd.Flags().StringVar(&startMigrationDir, "migration-dir", "",
		"path to the migration directory (will be created if it doesn't exist). Use with --assessment-control-plane and --migration-uuid.")
	startMigrationCmd.Flags().StringVar(&startAssessmentControlPlane, "assessment-control-plane", "",
		"connection string for the yugabyted control plane to pull assessment data from.")
	startMigrationCmd.Flags().StringVar(&startMigrationUUID, "migration-uuid", "",
		"migration UUID of a previously completed assessment (from the assessment UI).")
}

func runStartMigration() {
	// ── Validate flag combinations ──
	controlPlaneFlow := startMigrationDir != "" || startAssessmentControlPlane != "" || startMigrationUUID != ""
	configFileFlow := startMigrationConfigFile != ""

	if controlPlaneFlow && configFileFlow {
		utils.ErrExit("cannot use --config-file together with --migration-dir / --assessment-control-plane / --migration-uuid.\n" +
			"Use --config-file when you have an existing migration project, or use the control plane flags to bootstrap a new one.")
	}

	if controlPlaneFlow {
		if startMigrationDir == "" || startAssessmentControlPlane == "" || startMigrationUUID == "" {
			utils.ErrExit("when using the control plane flow, all three flags are required:\n" +
				"  --migration-dir, --assessment-control-plane, --migration-uuid")
		}
		bootstrapFromControlPlane()
		return
	}

	if !configFileFlow {
		utils.ErrExit("either --config-file or --migration-dir (with --assessment-control-plane and --migration-uuid) is required")
	}

	runStartMigrationWithConfig()
}

// runStartMigrationWithConfig is the existing flow: load a config file and continue.
func runStartMigrationWithConfig() {
	// Resolve config file path
	var err error
	startMigrationConfigFile, err = filepath.Abs(startMigrationConfigFile)
	if err != nil {
		utils.ErrExit("failed to resolve config file path: %v", err)
	}

	if !utils.FileOrFolderExists(startMigrationConfigFile) {
		utils.ErrExit("config file not found: %s\nRun 'yb-voyager init' first to create a migration project.", startMigrationConfigFile)
	}

	// Load config to read source details and export-dir
	v := viper.New()
	v.SetConfigType("yaml")
	v.SetConfigFile(startMigrationConfigFile)
	if err := v.ReadInConfig(); err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	continueStartMigration(v)
}

// continueStartMigration runs the shared portion of start-migration: assessment summary,
// source connection check, target prompt, workflow prompt, and config update.
func continueStartMigration(v *viper.Viper) {
	exportDirPath := v.GetString("export-dir")
	if exportDirPath == "" {
		utils.ErrExit("export-dir not set in config file: %s", startMigrationConfigFile)
	}

	// ── Section 1: Assessment Summary ──
	sourceDBType := v.GetString("source.db-type")
	sourceHost := v.GetString("source.db-host")
	sourcePort := v.GetInt("source.db-port")
	sourceDBName := v.GetString("source.db-name")

	assessmentReportPath := filepath.Join(exportDirPath, "assessment", "reports",
		fmt.Sprintf("%s.json", ASSESSMENT_FILE_NAME))
	assessmentDone := utils.FileOrFolderExists(assessmentReportPath)

	printAssessmentSection(sourceDBType, sourceHost, sourcePort, sourceDBName, assessmentDone, assessmentReportPath)

	if !assessmentDone {
		var proceed bool
		err := huh.NewConfirm().
			Title("Assessment has not been run. Proceed anyway?").
			Value(&proceed).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
		if !proceed {
			fmt.Println()
			fmt.Println("  Run assessment first:")
			fmt.Println("  " + cmdStyle.Render(fmt.Sprintf("yb-voyager assess-migration --config-file %s", displayPath(startMigrationConfigFile))))
			fmt.Println()
			return
		}
	}

	// ── Section 1b: Source connection ──
	// Try connecting to source DB; prompt for connection string if it fails.
	// Updates the config file and re-reads viper if source details change.
	tryConnectOrPromptSource(v, startMigrationConfigFile)

	// ── Section 2: Target connection ──
	var targetParsed *parsedConnInfo
	if targetConnStringFlag != "" {
		targetParsed = parseAndValidateTarget(targetConnStringFlag)
	} else {
		var targetConnString string
		for {
			err := huh.NewInput().
				Title("Enter the connection string for your target YugabyteDB").
				Description("Format: postgresql://user:password@host:5433/dbname").
				Placeholder("postgresql://yugabyte:yugabyte@localhost:5433/yugabyte").
				Value(&targetConnString).
				Run()
			if err != nil {
				utils.ErrExit("prompt failed: %v", err)
			}

			targetConnString = strings.TrimSpace(targetConnString)
			if targetConnString == "" {
				fmt.Println(color.RedString("  Target connection string is required."))
				continue
			}

			var parseErr error
			targetParsed, parseErr = parsePostgresConnString(targetConnString)
			if parseErr != nil {
				fmt.Println(color.RedString("  ✗ Invalid connection string: %v", parseErr))
				fmt.Println()
				continue
			}

			if err := validatePostgresConnection(targetConnString); err != nil {
				fmt.Println(color.RedString("  ✗ Connection failed: %v", err))
				fmt.Println()

				var retry bool
				huh.NewConfirm().
					Title("Would you like to try again?").
					Value(&retry).
					Run()
				if !retry {
					utils.ErrExit("Target connection is required to proceed.")
				}
				continue
			}
			break
		}
	}

	// ── Section 3: Workflow selection ──
	var workflow string
	if migrationWorkflowFlag != "" {
		workflow = migrationWorkflowFlag
		validWorkflows := []string{"offline", "live", "live-fall-back", "live-fall-forward"}
		valid := false
		for _, w := range validWorkflows {
			if workflow == w {
				valid = true
				break
			}
		}
		if !valid {
			utils.ErrExit("invalid workflow %q. Must be one of: offline, live, live-fall-back, live-fall-forward", workflow)
		}
	} else {
		err := huh.NewSelect[string]().
			Title("Select your data migration workflow").
			Options(
				huh.NewOption("Offline — One-time snapshot; requires downtime", "offline"),
				huh.NewOption("Live — Minimal downtime using change data capture", "live"),
				huh.NewOption("Live with fall-back — Can switch back to source if needed", "live-fall-back"),
				huh.NewOption("Live with fall-forward — Can switch to a source-replica if needed", "live-fall-forward"),
			).
			Value(&workflow).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
	}

	// Update config file
	updateConfigWithTargetAndWorkflow(startMigrationConfigFile, v, targetParsed, workflow)

	// ── Section 4: Configuring Migration (progressive checkmarks) ──
	printConfiguringSection(targetParsed, workflow, startMigrationConfigFile)

	// ── Section 5: What's Next ──
	printStartMigrationNextSteps(startMigrationConfigFile, v, workflow)
}

// bootstrapFromControlPlane sets up a new migration project by pulling assessment data
// from a shared control plane, then continues with the standard start-migration flow.
func bootstrapFromControlPlane() {
	// Resolve migration-dir to absolute path
	var err error
	startMigrationDir, err = filepath.Abs(startMigrationDir)
	if err != nil {
		utils.ErrExit("failed to resolve migration-dir path: %v", err)
	}

	configFilePath := filepath.Join(startMigrationDir, "config.yaml")
	exportDirPath := filepath.Join(startMigrationDir, "export-dir")

	// Idempotency guard
	if utils.FileOrFolderExists(configFilePath) {
		utils.ErrExit("migration directory %q already contains a config.yaml. "+
			"Use --config-file to continue with the existing project, or choose a different directory.", startMigrationDir)
	}

	// 1. Fetch assessment from control plane
	fmt.Printf("  Connecting to assessment control plane...\n")
	rec, err := yugabyted.FetchAssessmentFromControlPlane(startAssessmentControlPlane, startMigrationUUID)
	if err != nil {
		utils.ErrExit("failed to fetch assessment from control plane: %v", err)
	}

	var cpPayload AssessMigrationPayloadYugabyteD
	if err := json.Unmarshal([]byte(rec.Payload), &cpPayload); err != nil {
		utils.ErrExit("failed to parse control plane payload: %v", err)
	}
	if cpPayload.RawAssessmentJsonReport == "" {
		utils.ErrExit("the assessment stored in the control plane does not contain the raw assessment report. " +
			"Please re-run assess-migration with the latest version of yb-voyager to populate this field.")
	}

	fmt.Printf("  Found assessment for: %s - %s:%d/%s\n", rec.DBType, rec.HostIP, rec.Port, rec.DatabaseName)
	fmt.Printf("    Complexity: %s | Issues: %d\n", cpPayload.MigrationComplexity, len(cpPayload.AssessmentIssues))
	fmt.Println()

	// 2. Prompt for source connection details (password is never stored in control plane)
	var src *sourceConfig
	sourceConnStr := fmt.Sprintf("postgresql://%s:%d/%s", rec.HostIP, rec.Port, rec.DatabaseName)
	fmt.Printf("  Verifying source database connectivity to %s:%d/%s...\n", rec.HostIP, rec.Port, rec.DatabaseName)

	if connErr := validatePostgresConnection(sourceConnStr); connErr != nil {
		fmt.Println(color.YellowString("  Connection requires authentication or is unreachable."))
		fmt.Println()

		var userConnStr string
		for {
			err := huh.NewInput().
				Title("Enter the source database connection string").
				Description(fmt.Sprintf("Source from assessment: %s:%d/%s\nFormat: postgresql://user:password@host:port/dbname", rec.HostIP, rec.Port, rec.DatabaseName)).
				Value(&userConnStr).
				Run()
			if err != nil {
				utils.ErrExit("prompt failed: %v", err)
			}
			userConnStr = strings.TrimSpace(userConnStr)
			if userConnStr == "" {
				fmt.Println(color.YellowString("  No connection string provided. Proceeding without source connection verification."))
				src = &sourceConfig{
					DBType: rec.DBType,
					Host:   rec.HostIP,
					Port:   rec.Port,
					DBName: rec.DatabaseName,
					Schema: rec.SchemaName,
				}
				break
			}

			parsed, parseErr := parsePostgresConnString(userConnStr)
			if parseErr != nil {
				fmt.Println(color.RedString("  Invalid connection string: %v", parseErr))
				fmt.Println()
				continue
			}

			fmt.Printf("  Connecting to %s:%d...\n", parsed.Host, parsed.Port)
			if err := validatePostgresConnection(userConnStr); err != nil {
				fmt.Println(color.RedString("  Connection failed: %v", err))
				fmt.Println()

				var retry bool
				huh.NewConfirm().
					Title("Would you like to try again?").
					Value(&retry).
					Run()
				if !retry {
					fmt.Println(color.YellowString("  Proceeding without verified source connection."))
					src = &sourceConfig{
						DBType: rec.DBType,
						Host:   rec.HostIP,
						Port:   rec.Port,
						DBName: rec.DatabaseName,
						Schema: rec.SchemaName,
					}
					break
				}
				continue
			}

			schemas := parsed.Schema
			if schemas == "" {
				schemas = rec.SchemaName
			}
			if schemas == "" {
				schemas = "public"
			}
			src = &sourceConfig{
				DBType:   rec.DBType,
				Host:     parsed.Host,
				Port:     parsed.Port,
				DBName:   parsed.DBName,
				User:     parsed.User,
				Password: parsed.Password,
				Schema:   schemas,
			}
			fmt.Println("  " + successLine(fmt.Sprintf("Connected to %s:%d", parsed.Host, parsed.Port)))
			break
		}
	} else {
		fmt.Println("  " + successLine(fmt.Sprintf("Connected to %s:%d", rec.HostIP, rec.Port)))
		schema := rec.SchemaName
		if schema == "" {
			schema = "public"
		}
		src = &sourceConfig{
			DBType: rec.DBType,
			Host:   rec.HostIP,
			Port:   rec.Port,
			DBName: rec.DatabaseName,
			Schema: schema,
		}
	}

	// 3. Create export directory
	createExportDir(exportDirPath)

	// 4. Write the raw assessment JSON report
	reportDir := filepath.Join(exportDirPath, "assessment", "reports")
	jsonReportPath := filepath.Join(reportDir, fmt.Sprintf("%s%s", ASSESSMENT_FILE_NAME, JSON_EXTENSION))
	if err := os.WriteFile(jsonReportPath, []byte(cpPayload.RawAssessmentJsonReport), 0644); err != nil {
		utils.ErrExit("failed to write assessment report: %v", err)
	}

	// 5. Generate HTML report
	if err := json.Unmarshal([]byte(cpPayload.RawAssessmentJsonReport), &assessmentReport); err == nil {
		source.DBType = rec.DBType
		if htmlErr := generateAssessmentReportHtml(reportDir); htmlErr != nil {
			log.Warnf("failed to generate HTML assessment report: %v", htmlErr)
		}
	} else {
		log.Warnf("failed to parse raw assessment JSON for HTML generation: %v", err)
	}

	// 6. Generate config file with source details and assessment control plane
	generateConfigFile(configFilePath, exportDirPath, src, nil, startAssessmentControlPlane)

	// 7. Initialize metaDB with the same migration UUID
	mdb := initMetaDB(exportDirPath)
	err = mdb.UpdateMigrationStatusRecord(func(record *metadb.MigrationStatusRecord) {
		record.MigrationUUID = rec.MigrationUUID.String()
		record.MigrationAssessmentDone = true
	})
	if err != nil {
		utils.ErrExit("failed to update migration status record: %v", err)
	}

	// Print bootstrap summary
	printBootstrapSummary(rec, configFilePath, exportDirPath)

	// 8. Set up config file path for the rest of the flow and continue
	startMigrationConfigFile = configFilePath

	v := viper.New()
	v.SetConfigType("yaml")
	v.SetConfigFile(startMigrationConfigFile)
	if err := v.ReadInConfig(); err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	// Continue with the standard start-migration flow (target + workflow)
	continueStartMigration(v)
}

// printBootstrapSummary prints progress checkmarks after bootstrapping from the control plane.
func printBootstrapSummary(rec *yugabyted.AssessmentRecord, configFilePath, exportDirPath string) {
	fmt.Println()
	fmt.Println("  " + titleStyle.Render("Bootstrapping Migration from Control Plane"))
	fmt.Println("  " + ruleStyle.Render(strings.Repeat("─", ruleWidth)))

	steps := []string{
		successLine("Connected to assessment control plane"),
		successLine(fmt.Sprintf("Imported assessment for          %s - %s:%d/%s", rec.DBType, rec.HostIP, rec.Port, rec.DatabaseName)),
		successLine("Created migration workspace      " + dimStyle.Render(displayPath(exportDirPath))),
		successLine("Imported assessment report        " + dimStyle.Render(displayPath(filepath.Join(exportDirPath, "assessment", "reports", ASSESSMENT_FILE_NAME+JSON_EXTENSION)))),
		successLine("Generated config                 " + dimStyle.Render(displayPath(configFilePath))),
	}
	for _, step := range steps {
		time.Sleep(500 * time.Millisecond)
		fmt.Println("  " + step)
	}
	time.Sleep(500 * time.Millisecond)
	fmt.Println()
	fmt.Println("  " + successStyle.Render("Done!"))
	fmt.Println()

	// UI link
	uiHost := "localhost"
	if parsed, pErr := url.Parse(startAssessmentControlPlane); pErr == nil && parsed.Hostname() != "" {
		uiHost = parsed.Hostname()
	}
	fmt.Println("  " + dimStyle.Render(fmt.Sprintf("View assessment in UI: http://%s:15433/migrations?migration_uuid=%s", uiHost, rec.MigrationUUID.String())))
	fmt.Println()
}

// parseAndValidateTarget parses and validates a target connection string provided via flag.
func parseAndValidateTarget(connStr string) *parsedConnInfo {
	connStr = strings.TrimSpace(connStr)
	parsed, err := parsePostgresConnString(connStr)
	if err != nil {
		utils.ErrExit("Invalid target connection string: %v", err)
	}
	if err := validatePostgresConnection(connStr); err != nil {
		utils.ErrExit("Target connection failed: %v", err)
	}
	return parsed
}

// printAssessmentSection prints the "Start Migration" header with source + assessment summary.
func printAssessmentSection(dbType, host string, port int, dbName string, assessmentDone bool, assessmentReportPath string) {
	kw := 13
	indent := strings.Repeat(" ", kw+1) // indent for continuation lines under key-value pairs

	var lines []string

	if dbType != "" {
		lines = append(lines, formatKeyValue("Source:", fmt.Sprintf("%s @ %s:%d/%s", titleCase(dbType), host, port, dbName), kw))
	}

	if assessmentDone {
		lines = append(lines, formatKeyValue("Assessment:", successStyle.Render("✓ completed"), kw))
		sizingInfo := loadAssessmentSizing(assessmentReportPath)
		if sizingInfo != "" {
			lines = append(lines, indent+sizingInfo)
		}
		htmlReportPath := strings.TrimSuffix(assessmentReportPath, ".json") + ".html"
		lines = append(lines, indent+dimStyle.Render("Report: "+displayPath(htmlReportPath)))
	} else {
		lines = append(lines, formatKeyValue("Assessment:", warnStyle.Render("not yet run"), kw))
	}

	printSection("Assessment Summary", lines...)
	fmt.Println()
}

// printConfiguringSection prints progressive checkmarks for target + workflow configuration.
func printConfiguringSection(target *parsedConnInfo, workflow, configFilePath string) {
	fmt.Println()
	fmt.Println("  " + titleStyle.Render("Starting Migration"))
	fmt.Println("  " + ruleStyle.Render(strings.Repeat("─", ruleWidth)))

	targetLine := fmt.Sprintf("YugabyteDB @ %s:%d/%s", target.Host, target.Port, target.DBName)
	fmt.Println("  " + formatKeyValue("Target:", targetLine, 10))
	fmt.Println("  " + formatKeyValue("Workflow:", workflowDisplayName(workflow), 10))
	fmt.Println()

	steps := []string{
		successLine("Connected to target database"),
		successLine("Updated config  " + dimStyle.Render(displayPath(configFilePath))),
	}
	for _, step := range steps {
		time.Sleep(1 * time.Second)
		fmt.Println("  " + step)
	}
	time.Sleep(500 * time.Millisecond)
	fmt.Println()
	fmt.Println("  " + successStyle.Render("Done!"))
	fmt.Println()
}

// loadAssessmentSizing reads the assessment report and returns a short sizing summary string.
func loadAssessmentSizing(reportPath string) string {
	data, err := os.ReadFile(reportPath)
	if err != nil {
		return ""
	}
	var report AssessmentReport
	if err := json.Unmarshal(data, &report); err != nil {
		return ""
	}
	if report.Sizing == nil {
		return ""
	}
	sr := report.Sizing.SizingRecommendation
	result := fmt.Sprintf("%.0f nodes, %d vCPU / %d GB each recommended",
		math.Ceil(sr.NumNodes), sr.VCPUsPerInstance, sr.MemoryPerInstance)
	if report.Sizing.FailureReasoning != "" {
		result += " (" + report.Sizing.FailureReasoning + ")"
	}
	return result
}

// workflowDisplayName returns a human-readable name for a workflow identifier.
func workflowDisplayName(workflow string) string {
	switch workflow {
	case "offline":
		return "Offline (snapshot)"
	case "live":
		return "Live (CDC)"
	case "live-fall-back":
		return "Live with fall-back"
	case "live-fall-forward":
		return "Live with fall-forward"
	default:
		return titleCase(workflow)
	}
}

func updateConfigWithTargetAndWorkflow(configFilePath string, v *viper.Viper, target *parsedConnInfo, workflow string) {
	// Read the existing config file content
	data, err := os.ReadFile(configFilePath)
	if err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	content := string(data)

	// The config was generated from the offline-migration.yaml template which already has
	// target and export-data/import-data sections with placeholder values.
	// We do in-place replacements on those sections.

	// --- Target replacements ---
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-host: 127.0.0.1", fmt.Sprintf("db-host: %s", target.Host))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-port: 5433", fmt.Sprintf("db-port: %d", target.Port))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-name: yugabyte", fmt.Sprintf("db-name: %s", target.DBName))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-user: test_user", fmt.Sprintf("db-user: %s", target.User))
	if target.Password != "" {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"db-password: test_password", fmt.Sprintf("db-password: '%s'", strings.ReplaceAll(target.Password, "'", "''")))
	} else {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"  db-password: test_password", "  # db-password: <password>  # Or set TARGET_DB_PASSWORD env var")
	}

	// --- Workflow: for offline migration, the template already has the correct export-type ---
	// For non-offline workflows, we would need to change export-type and add extra sections.
	// For the POC, offline is the primary workflow.
	switch workflow {
	case "offline":
		// Template already has export-type: snapshot-only — nothing to change
	case "live", "live-fall-back", "live-fall-forward":
		// Change export-type from snapshot-only to snapshot-and-changes
		content = strings.Replace(content, "export-type: snapshot-only", "export-type: snapshot-and-changes", 1)
	}

	if err := os.WriteFile(configFilePath, []byte(content), 0644); err != nil {
		utils.ErrExit("failed to update config file: %v", err)
	}
}

func titleCase(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// tryConnectOrPromptSource attempts to connect to the source database using values
// from the config file. If the connection fails (or required fields are missing),
// it prompts the user for a connection string, validates it, updates the config
// file, and re-reads viper.
func tryConnectOrPromptSource(v *viper.Viper, configFilePath string) *parsedConnInfo {
	host := v.GetString("source.db-host")
	port := v.GetInt("source.db-port")
	user := v.GetString("source.db-user")
	password := v.GetString("source.db-password")
	dbName := v.GetString("source.db-name")
	schema := v.GetString("source.db-schema")

	// If required fields are present, try connecting
	if host != "" && user != "" && dbName != "" {
		if port == 0 {
			port = 5432
		}
		connStr := buildPostgresConnString(host, port, user, password, dbName)
		if err := validatePostgresConnection(connStr); err == nil {
			return &parsedConnInfo{
				Host:     host,
				Port:     port,
				User:     user,
				Password: password,
				DBName:   dbName,
				Schema:   schema,
			}
		}
		// Connection failed with explicit config values -- let the user know
		fmt.Println(color.YellowString("  Could not connect to source database (%s@%s:%d/%s).", user, host, port, dbName))
		fmt.Println()
	}
	// If fields are missing (generate-scripts / skip flow), go straight to the prompt

	// Prompt for connection string
	var connString string
	var parsed *parsedConnInfo
	for {
		err := huh.NewInput().
			Title("Enter your source PostgreSQL connection string").
			Description("Format: postgresql://user:password@host:port/dbname").
			Value(&connString).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}

		connString = strings.TrimSpace(connString)
		if connString == "" {
			fmt.Println(color.RedString("  Source connection string is required."))
			continue
		}

		var parseErr error
		parsed, parseErr = parsePostgresConnString(connString)
		if parseErr != nil {
			fmt.Println(color.RedString("  ✗ Invalid connection string: %v", parseErr))
			fmt.Println()
			continue
		}

		fmt.Printf("  Connecting to %s:%d...\n", parsed.Host, parsed.Port)
		if err := validatePostgresConnection(connString); err != nil {
			fmt.Println(color.RedString("  ✗ Connection failed: %v", err))
			fmt.Println()

			var retry bool
			huh.NewConfirm().
				Title("Would you like to try again?").
				Value(&retry).
				Run()
			if !retry {
				utils.ErrExit("Source connection is required to proceed.")
			}
			continue
		}

		fmt.Println(color.GreenString("  ✓ Connected to source database"))
		fmt.Println()
		break
	}

	// Update config file with real source details
	schemas := parsed.Schema
	if schemas == "" {
		schemas = "public"
	}
	updateConfigWithSource(configFilePath, &sourceConfig{
		DBType:   "postgresql",
		Host:     parsed.Host,
		Port:     parsed.Port,
		DBName:   parsed.DBName,
		User:     parsed.User,
		Password: parsed.Password,
		Schema:   schemas,
	})

	// Re-read config so the rest of the flow sees real values
	if err := v.ReadInConfig(); err != nil {
		utils.ErrExit("failed to re-read config file after source update: %v", err)
	}

	return parsed
}

// buildPostgresConnString constructs a postgresql:// connection string from individual components.
func buildPostgresConnString(host string, port int, user, password, dbName string) string {
	var userInfo string
	if password != "" {
		userInfo = fmt.Sprintf("%s:%s", user, password)
	} else {
		userInfo = user
	}
	return fmt.Sprintf("postgresql://%s@%s:%d/%s", userInfo, host, port, dbName)
}

// updateConfigWithSource updates the source connection fields in the config file.
// It handles both commented-out fields (from the generate-scripts/skip flow) and
// template default values.
func updateConfigWithSource(configFilePath string, src *sourceConfig) {
	data, err := os.ReadFile(configFilePath)
	if err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	content := string(data)

	content = replaceConfigValue(content, "db-type:", "postgresql", src.DBType)

	// Each field may be commented out (# db-host: ...) or have a template default (db-host: localhost).
	// Try the commented-out form first, then fall back to the template default.
	sourceReplacements := []struct {
		commentedOut string
		templateVal  string
		newVal       string
	}{
		{"  # db-host: localhost", "  db-host: localhost", fmt.Sprintf("  db-host: %s", src.Host)},
		{"  # db-port: 5432", "  db-port: 5432", fmt.Sprintf("  db-port: %d", src.Port)},
		{"  # db-name: <database-name>", "  db-name: test_db", fmt.Sprintf("  db-name: %s", src.DBName)},
		{"  # db-schema: public", "  db-schema: public", fmt.Sprintf("  db-schema: %s", src.Schema)},
		{"  # db-user: <username>", "  db-user: test_user", fmt.Sprintf("  db-user: %s", src.User)},
	}

	for _, r := range sourceReplacements {
		replaced := replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
			r.commentedOut, r.newVal)
		if replaced != content {
			content = replaced
		} else {
			content = replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
				r.templateVal, r.newVal)
		}
	}

	// Handle password
	if src.Password != "" {
		passwordVal := fmt.Sprintf("  db-password: '%s'", strings.ReplaceAll(src.Password, "'", "''"))
		replaced := replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
			"  # db-password: <password>  # Or set SOURCE_DB_PASSWORD env var", passwordVal)
		if replaced != content {
			content = replaced
		} else {
			content = replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
				"  db-password: test_password", passwordVal)
		}
	} else {
		content = replaceInSection(content, "Source Database Configuration", "Target Database Configuration",
			"  db-password: test_password", "  # db-password: <password>  # Or set SOURCE_DB_PASSWORD env var")
	}

	if err := os.WriteFile(configFilePath, []byte(content), 0644); err != nil {
		utils.ErrExit("failed to update config file with source details: %v", err)
	}
}

func printStartMigrationNextSteps(configFilePath string, v *viper.Viper, workflow string) {
	var lines []string

	step := 1

	// Check if permissions need granting
	sourceDBType := v.GetString("source.db-type")
	if sourceDBType == "postgresql" && (workflow == "live" || workflow == "live-fall-back" || workflow == "live-fall-forward") {
		sourceHost := v.GetString("source.db-host")
		sourceDBName := v.GetString("source.db-name")
		sourceUser := v.GetString("source.db-user")

		lines = append(lines, fmt.Sprintf("%d. Grant permissions for live migration:", step))
		lines = append(lines, "")
		lines = append(lines, cmdStyle.Render(fmt.Sprintf("  psql -h %s -d %s -U %s \\\n    -f /opt/yb-voyager/guardrails-scripts/yb-voyager-pg-grant-migration-permissions.sql",
			sourceHost, sourceDBName, sourceUser)))
		lines = append(lines, "")
		step++
	}

	if step == 1 {
		lines = append(lines, "Export the schema from your source database:")
	} else {
		lines = append(lines, fmt.Sprintf("%d. Export schema:", step))
	}
	lines = append(lines, "")
	lines = append(lines, cmdStyle.Render(fmt.Sprintf("  yb-voyager export schema \\\n    --config-file %s",
		displayPath(configFilePath))))

	printSection("What's Next", lines...)
	fmt.Println()
}
