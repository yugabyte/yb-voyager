/*
Copyright (c) YugabyteDB, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cmd

import (
	"encoding/json"
	"fmt"
	"math"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/charmbracelet/huh"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils"
)

var startMigrationCmd = &cobra.Command{
	Use:   "start-migration",
	Short: "Set up target database and migration workflow",
	Long: `Set up target database connection and select migration workflow.

This command should be run after assess-migration has completed. It will:
  - Display the assessment summary
  - Prompt for target YugabyteDB connection details
  - Let you choose a migration workflow (offline, live, etc.)
  - Update the config file with the target and workflow settings`,

	Run: func(cmd *cobra.Command, args []string) {
		runStartMigration()
	},
}

var startMigrationConfigFile string
var targetConnStringFlag string
var migrationWorkflowFlag string

func init() {
	rootCmd.AddCommand(startMigrationCmd)
	startMigrationCmd.Flags().StringVarP(&startMigrationConfigFile, "config-file", "c", "",
		"path to the config file generated by 'yb-voyager init'")
	startMigrationCmd.MarkFlagRequired("config-file")
	startMigrationCmd.Flags().StringVar(&targetConnStringFlag, "target-db-connection-string", "",
		"target YugabyteDB connection string (e.g. postgresql://yugabyte:yugabyte@host:5433/dbname). If provided, skips the interactive prompt.")
	startMigrationCmd.Flags().StringVar(&migrationWorkflowFlag, "workflow", "",
		"migration workflow: offline, live, live-fall-back, live-fall-forward. If provided, skips the interactive prompt.")
}

func runStartMigration() {
	// Resolve config file path
	var err error
	startMigrationConfigFile, err = filepath.Abs(startMigrationConfigFile)
	if err != nil {
		utils.ErrExit("failed to resolve config file path: %v", err)
	}

	if !utils.FileOrFolderExists(startMigrationConfigFile) {
		utils.ErrExit("config file not found: %s\nRun 'yb-voyager init' first to create a migration project.", startMigrationConfigFile)
	}

	// Load config to read source details and export-dir
	v := viper.New()
	v.SetConfigType("yaml")
	v.SetConfigFile(startMigrationConfigFile)
	if err := v.ReadInConfig(); err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	exportDirPath := v.GetString("export-dir")
	if exportDirPath == "" {
		utils.ErrExit("export-dir not set in config file: %s", startMigrationConfigFile)
	}

	sourceDBType := v.GetString("source.db-type")
	sourceHost := v.GetString("source.db-host")
	sourcePort := v.GetInt("source.db-port")
	sourceDBName := v.GetString("source.db-name")

	// ── Section 1: Assessment Summary ──
	assessmentReportPath := filepath.Join(exportDirPath, "assessment", "reports",
		fmt.Sprintf("%s.json", ASSESSMENT_FILE_NAME))
	assessmentDone := utils.FileOrFolderExists(assessmentReportPath)

	printAssessmentSection(sourceDBType, sourceHost, sourcePort, sourceDBName, assessmentDone, assessmentReportPath)

	if !assessmentDone {
		var proceed bool
		err := huh.NewConfirm().
			Title("Assessment has not been run. Proceed anyway?").
			Value(&proceed).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
		if !proceed {
			fmt.Println()
			fmt.Println("  Run assessment first:")
			fmt.Println("  " + cmdStyle.Render(fmt.Sprintf("yb-voyager assess-migration --config-file %s", displayPath(startMigrationConfigFile))))
			fmt.Println()
			return
		}
	}

	// ── Section 2: Target connection ──
	var targetParsed *parsedConnInfo
	if targetConnStringFlag != "" {
		targetParsed = parseAndValidateTarget(targetConnStringFlag)
	} else {
		var targetConnString string
		for {
			err := huh.NewInput().
				Title("Enter the connection string for your target YugabyteDB").
				Description("Format: postgresql://user:password@host:5433/dbname").
				Placeholder("postgresql://yugabyte:yugabyte@localhost:5433/yugabyte").
				Value(&targetConnString).
				Run()
			if err != nil {
				utils.ErrExit("prompt failed: %v", err)
			}

			targetConnString = strings.TrimSpace(targetConnString)
			if targetConnString == "" {
				fmt.Println(color.RedString("  Target connection string is required."))
				continue
			}

			var parseErr error
			targetParsed, parseErr = parsePostgresConnString(targetConnString)
			if parseErr != nil {
				fmt.Println(color.RedString("  ✗ Invalid connection string: %v", parseErr))
				fmt.Println()
				continue
			}

			if err := validatePostgresConnection(targetConnString); err != nil {
				fmt.Println(color.RedString("  ✗ Connection failed: %v", err))
				fmt.Println()

				var retry bool
				huh.NewConfirm().
					Title("Would you like to try again?").
					Value(&retry).
					Run()
				if !retry {
					utils.ErrExit("Target connection is required to proceed.")
				}
				continue
			}
			break
		}
	}

	// ── Section 3: Workflow selection ──
	var workflow string
	if migrationWorkflowFlag != "" {
		workflow = migrationWorkflowFlag
		validWorkflows := []string{"offline", "live", "live-fall-back", "live-fall-forward"}
		valid := false
		for _, w := range validWorkflows {
			if workflow == w {
				valid = true
				break
			}
		}
		if !valid {
			utils.ErrExit("invalid workflow %q. Must be one of: offline, live, live-fall-back, live-fall-forward", workflow)
		}
	} else {
		err = huh.NewSelect[string]().
			Title("Select your data migration workflow").
			Options(
				huh.NewOption("Offline — One-time snapshot; requires downtime", "offline"),
				huh.NewOption("Live — Minimal downtime using change data capture", "live"),
				huh.NewOption("Live with fall-back — Can switch back to source if needed", "live-fall-back"),
				huh.NewOption("Live with fall-forward — Can switch to a source-replica if needed", "live-fall-forward"),
			).
			Value(&workflow).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
	}

	// Update config file
	updateConfigWithTargetAndWorkflow(startMigrationConfigFile, v, targetParsed, workflow)

	// ── Section 4: Configuring Migration (progressive checkmarks) ──
	printConfiguringSection(targetParsed, workflow, startMigrationConfigFile)

	// ── Section 5: What's Next ──
	printStartMigrationNextSteps(startMigrationConfigFile, v, workflow)
}

// parseAndValidateTarget parses and validates a target connection string provided via flag.
func parseAndValidateTarget(connStr string) *parsedConnInfo {
	connStr = strings.TrimSpace(connStr)
	parsed, err := parsePostgresConnString(connStr)
	if err != nil {
		utils.ErrExit("Invalid target connection string: %v", err)
	}
	if err := validatePostgresConnection(connStr); err != nil {
		utils.ErrExit("Target connection failed: %v", err)
	}
	return parsed
}

// printAssessmentSection prints the "Start Migration" header with source + assessment summary.
func printAssessmentSection(dbType, host string, port int, dbName string, assessmentDone bool, assessmentReportPath string) {
	kw := 13
	indent := strings.Repeat(" ", kw+1) // indent for continuation lines under key-value pairs

	var lines []string

	if dbType != "" {
		lines = append(lines, formatKeyValue("Source:", fmt.Sprintf("%s @ %s:%d/%s", titleCase(dbType), host, port, dbName), kw))
	}

	if assessmentDone {
		lines = append(lines, formatKeyValue("Assessment:", successStyle.Render("✓ completed"), kw))
		sizingInfo := loadAssessmentSizing(assessmentReportPath)
		if sizingInfo != "" {
			lines = append(lines, indent+sizingInfo)
		}
		htmlReportPath := strings.TrimSuffix(assessmentReportPath, ".json") + ".html"
		lines = append(lines, indent+dimStyle.Render("Report: "+displayPath(htmlReportPath)))
	} else {
		lines = append(lines, formatKeyValue("Assessment:", warnStyle.Render("not yet run"), kw))
	}

	printSection("Assessment Summary", lines...)
	fmt.Println()
}

// printConfiguringSection prints progressive checkmarks for target + workflow configuration.
func printConfiguringSection(target *parsedConnInfo, workflow, configFilePath string) {
	fmt.Println()
	fmt.Println("  " + titleStyle.Render("Starting Migration"))
	fmt.Println("  " + ruleStyle.Render(strings.Repeat("─", ruleWidth)))

	targetLine := fmt.Sprintf("YugabyteDB @ %s:%d/%s", target.Host, target.Port, target.DBName)
	fmt.Println("  " + formatKeyValue("Target:", targetLine, 10))
	fmt.Println("  " + formatKeyValue("Workflow:", workflowDisplayName(workflow), 10))
	fmt.Println()

	steps := []string{
		successLine("Connected to target database"),
		successLine("Updated config  " + dimStyle.Render(displayPath(configFilePath))),
	}
	for _, step := range steps {
		time.Sleep(1 * time.Second)
		fmt.Println("  " + step)
	}
	time.Sleep(500 * time.Millisecond)
	fmt.Println()
	fmt.Println("  " + successStyle.Render("Done!"))
	fmt.Println()
}

// loadAssessmentSizing reads the assessment report and returns a short sizing summary string.
func loadAssessmentSizing(reportPath string) string {
	data, err := os.ReadFile(reportPath)
	if err != nil {
		return ""
	}
	var report AssessmentReport
	if err := json.Unmarshal(data, &report); err != nil {
		return ""
	}
	if report.Sizing == nil {
		return ""
	}
	sr := report.Sizing.SizingRecommendation
	result := fmt.Sprintf("%.0f nodes, %d vCPU / %d GB each recommended",
		math.Ceil(sr.NumNodes), sr.VCPUsPerInstance, sr.MemoryPerInstance)
	if report.Sizing.FailureReasoning != "" {
		result += " (" + report.Sizing.FailureReasoning + ")"
	}
	return result
}

// workflowDisplayName returns a human-readable name for a workflow identifier.
func workflowDisplayName(workflow string) string {
	switch workflow {
	case "offline":
		return "Offline (snapshot)"
	case "live":
		return "Live (CDC)"
	case "live-fall-back":
		return "Live with fall-back"
	case "live-fall-forward":
		return "Live with fall-forward"
	default:
		return titleCase(workflow)
	}
}

func updateConfigWithTargetAndWorkflow(configFilePath string, v *viper.Viper, target *parsedConnInfo, workflow string) {
	// Read the existing config file content
	data, err := os.ReadFile(configFilePath)
	if err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	content := string(data)

	// The config was generated from the offline-migration.yaml template which already has
	// target and export-data/import-data sections with placeholder values.
	// We do in-place replacements on those sections.

	// --- Target replacements ---
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-host: 127.0.0.1", fmt.Sprintf("db-host: %s", target.Host))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-port: 5433", fmt.Sprintf("db-port: %d", target.Port))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-name: yugabyte", fmt.Sprintf("db-name: %s", target.DBName))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-user: test_user", fmt.Sprintf("db-user: %s", target.User))
	if target.Password != "" {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"db-password: test_password", fmt.Sprintf("db-password: '%s'", strings.ReplaceAll(target.Password, "'", "''")))
	} else {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"  db-password: test_password", "  # db-password: <password>  # Or set TARGET_DB_PASSWORD env var")
	}

	// --- Workflow: for offline migration, the template already has the correct export-type ---
	// For non-offline workflows, we would need to change export-type and add extra sections.
	// For the POC, offline is the primary workflow.
	switch workflow {
	case "offline":
		// Template already has export-type: snapshot-only — nothing to change
	case "live", "live-fall-back", "live-fall-forward":
		// Change export-type from snapshot-only to snapshot-and-changes
		content = strings.Replace(content, "export-type: snapshot-only", "export-type: snapshot-and-changes", 1)
	}

	if err := os.WriteFile(configFilePath, []byte(content), 0644); err != nil {
		utils.ErrExit("failed to update config file: %v", err)
	}
}

func titleCase(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func printStartMigrationNextSteps(configFilePath string, v *viper.Viper, workflow string) {
	var lines []string

	step := 1

	// Check if permissions need granting
	sourceDBType := v.GetString("source.db-type")
	if sourceDBType == "postgresql" && (workflow == "live" || workflow == "live-fall-back" || workflow == "live-fall-forward") {
		sourceHost := v.GetString("source.db-host")
		sourceDBName := v.GetString("source.db-name")
		sourceUser := v.GetString("source.db-user")

		lines = append(lines, fmt.Sprintf("%d. Grant permissions for live migration:", step))
		lines = append(lines, "")
		lines = append(lines, cmdStyle.Render(fmt.Sprintf("  psql -h %s -d %s -U %s \\\n    -f /opt/yb-voyager/guardrails-scripts/yb-voyager-pg-grant-migration-permissions.sql",
			sourceHost, sourceDBName, sourceUser)))
		lines = append(lines, "")
		step++
	}

	if step == 1 {
		lines = append(lines, "Export the schema from your source database:")
	} else {
		lines = append(lines, fmt.Sprintf("%d. Export schema:", step))
	}
	lines = append(lines, "")
	lines = append(lines, cmdStyle.Render(fmt.Sprintf("  yb-voyager export schema \\\n    --config-file %s",
		displayPath(configFilePath))))

	printSection("What's Next", lines...)
	fmt.Println()
}
