/*
Copyright (c) YugabyteDB, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cmd

import (
	"encoding/json"
	"fmt"
	"math"
	"os"
	"path/filepath"
	"strings"

	"github.com/charmbracelet/huh"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils"
)

var startMigrationCmd = &cobra.Command{
	Use:   "start-migration",
	Short: "Set up target database and migration workflow",
	Long: `Set up target database connection and select migration workflow.

This command should be run after assess-migration has completed. It will:
  - Display the assessment summary
  - Prompt for target YugabyteDB connection details
  - Let you choose a migration workflow (offline, live, etc.)
  - Update the config file with the target and workflow settings`,

	Run: func(cmd *cobra.Command, args []string) {
		runStartMigration()
	},
}

var startMigrationConfigFile string
var targetConnStringFlag string
var migrationWorkflowFlag string

func init() {
	rootCmd.AddCommand(startMigrationCmd)
	startMigrationCmd.Flags().StringVarP(&startMigrationConfigFile, "config-file", "c", "",
		"path to the config file generated by 'yb-voyager init'")
	startMigrationCmd.MarkFlagRequired("config-file")
	startMigrationCmd.Flags().StringVar(&targetConnStringFlag, "target-db-connection-string", "",
		"target YugabyteDB connection string (e.g. postgresql://yugabyte:yugabyte@host:5433/dbname). If provided, skips the interactive prompt.")
	startMigrationCmd.Flags().StringVar(&migrationWorkflowFlag, "workflow", "",
		"migration workflow: offline, live, live-fall-back, live-fall-forward. If provided, skips the interactive prompt.")
}

func runStartMigration() {
	// Resolve config file path
	var err error
	startMigrationConfigFile, err = filepath.Abs(startMigrationConfigFile)
	if err != nil {
		utils.ErrExit("failed to resolve config file path: %v", err)
	}

	if !utils.FileOrFolderExists(startMigrationConfigFile) {
		utils.ErrExit("config file not found: %s\nRun 'yb-voyager init' first to create a migration project.", startMigrationConfigFile)
	}

	// Load config to read source details and export-dir
	v := viper.New()
	v.SetConfigType("yaml")
	v.SetConfigFile(startMigrationConfigFile)
	if err := v.ReadInConfig(); err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	exportDirPath := v.GetString("export-dir")
	if exportDirPath == "" {
		utils.ErrExit("export-dir not set in config file: %s", startMigrationConfigFile)
	}

	sourceDBType := v.GetString("source.db-type")
	sourceHost := v.GetString("source.db-host")
	sourcePort := v.GetInt("source.db-port")
	sourceDBName := v.GetString("source.db-name")

	// Check if assessment has been run
	assessmentReportPath := filepath.Join(exportDirPath, "assessment", "reports",
		fmt.Sprintf("%s.json", ASSESSMENT_FILE_NAME))

	assessmentDone := utils.FileOrFolderExists(assessmentReportPath)

	printStartMigrationBanner(sourceDBType, sourceHost, sourcePort, sourceDBName, assessmentDone)

	if assessmentDone {
		displayAssessmentSummary(assessmentReportPath)
	} else {
		fmt.Println(color.YellowString("  Warning: Assessment has not been run yet."))
		fmt.Println(color.YellowString("  It is recommended to run 'yb-voyager assess-migration' before starting migration."))
		fmt.Println()

		var proceed bool
		err := huh.NewConfirm().
			Title("Would you like to proceed without assessment?").
			Value(&proceed).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
		if !proceed {
			fmt.Println("\n  Run assessment first:")
			fmt.Printf("  yb-voyager assess-migration --config-file %s\n\n", startMigrationConfigFile)
			return
		}
	}

	// --- Target connection ---
	var targetParsed *parsedConnInfo
	if targetConnStringFlag != "" {
		// Non-interactive: use flag value
		targetParsed = parseAndValidateTarget(targetConnStringFlag)
	} else {
		// Interactive prompt
		fmt.Println("Before proceeding:")
		fmt.Println("  1. Ensure your target YugabyteDB cluster is created and running.")
		fmt.Println("  2. Create a database on the target cluster.")
		fmt.Println("  3. Create a superuser: CREATE USER ybvoyager SUPERUSER PASSWORD 'password';")
		fmt.Println()

		var targetConnString string
		for {
			err := huh.NewInput().
				Title("Enter the connection string for your target YugabyteDB").
				Description("Format: postgresql://user:password@host:5433/dbname").
				Placeholder("postgresql://yugabyte:yugabyte@localhost:5433/yugabyte").
				Value(&targetConnString).
				Run()
			if err != nil {
				utils.ErrExit("prompt failed: %v", err)
			}

			targetConnString = strings.TrimSpace(targetConnString)
			if targetConnString == "" {
				fmt.Println(color.RedString("  Target connection string is required."))
				continue
			}

			var parseErr error
			targetParsed, parseErr = parsePostgresConnString(targetConnString)
			if parseErr != nil {
				fmt.Println(color.RedString("  ✗ Invalid connection string: %v", parseErr))
				fmt.Println()
				continue
			}

			fmt.Printf("  Connecting to %s:%d...\n", targetParsed.Host, targetParsed.Port)
			if err := validatePostgresConnection(targetConnString); err != nil {
				fmt.Println(color.RedString("  ✗ Connection failed: %v", err))
				fmt.Println()

				var retry bool
				huh.NewConfirm().
					Title("Would you like to try again?").
					Value(&retry).
					Run()
				if !retry {
					utils.ErrExit("Target connection is required to proceed.")
				}
				continue
			}

			fmt.Println(color.GreenString("  ✓ Connected to %s:%d", targetParsed.Host, targetParsed.Port))
			fmt.Println()
			break
		}
	}

	// --- Workflow selection ---
	var workflow string
	if migrationWorkflowFlag != "" {
		workflow = migrationWorkflowFlag
		validWorkflows := []string{"offline", "live", "live-fall-back", "live-fall-forward"}
		valid := false
		for _, w := range validWorkflows {
			if workflow == w {
				valid = true
				break
			}
		}
		if !valid {
			utils.ErrExit("invalid workflow %q. Must be one of: offline, live, live-fall-back, live-fall-forward", workflow)
		}
	} else {
		err = huh.NewSelect[string]().
			Title("Select your data migration workflow").
			Options(
				huh.NewOption("Offline — One-time snapshot; requires downtime", "offline"),
				huh.NewOption("Live — Minimal downtime using change data capture", "live"),
				huh.NewOption("Live with fall-back — Can switch back to source if needed", "live-fall-back"),
				huh.NewOption("Live with fall-forward — Can switch to a source-replica if needed", "live-fall-forward"),
			).
			Value(&workflow).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
	}

	// Update config file with target details and workflow
	updateConfigWithTargetAndWorkflow(startMigrationConfigFile, v, targetParsed, workflow)

	fmt.Println(color.GreenString("  ✓ Updated config: %s", startMigrationConfigFile))

	printStartMigrationNextSteps(startMigrationConfigFile, v, workflow)
}

// parseAndValidateTarget parses and validates a target connection string provided via flag.
func parseAndValidateTarget(connStr string) *parsedConnInfo {
	connStr = strings.TrimSpace(connStr)
	parsed, err := parsePostgresConnString(connStr)
	if err != nil {
		utils.ErrExit("Invalid target connection string: %v", err)
	}
	fmt.Printf("  Connecting to target %s:%d...\n", parsed.Host, parsed.Port)
	if err := validatePostgresConnection(connStr); err != nil {
		utils.ErrExit("Target connection failed: %v", err)
	}
	fmt.Println(color.GreenString("  ✓ Connected to target %s:%d", parsed.Host, parsed.Port))
	fmt.Println()
	return parsed
}

func printStartMigrationBanner(dbType, host string, port int, dbName string, assessmentDone bool) {
	fmt.Println()
	fmt.Println("══════════════════════════════════════════════════════════════")
	fmt.Println("                    Start Migration")
	fmt.Println("══════════════════════════════════════════════════════════════")
	fmt.Println()

	if dbType != "" {
		fmt.Printf("Source: %s — %s:%d/%s\n", titleCase(dbType), host, port, dbName)
	}

	if assessmentDone {
		fmt.Println("Assessment: completed ✓")
	} else {
		fmt.Println(color.YellowString("Assessment: not yet run"))
	}
	fmt.Println()
}

func displayAssessmentSummary(reportPath string) {
	data, err := os.ReadFile(reportPath)
	if err != nil {
		fmt.Println(color.YellowString("  Warning: could not read assessment report: %v", err))
		return
	}

	var report AssessmentReport
	if err := json.Unmarshal(data, &report); err != nil {
		fmt.Println(color.YellowString("  Warning: could not parse assessment report: %v", err))
		return
	}

	fmt.Println("  Your assessment report recommended:")

	if report.Sizing != nil {
		sr := report.Sizing.SizingRecommendation
		fmt.Printf("    • Target YB cluster size: %.0f nodes, %d vCPU / %d GB RAM each\n",
			math.Ceil(sr.NumNodes), sr.VCPUsPerInstance, sr.MemoryPerInstance)
	}

	if report.Sizing != nil && report.Sizing.FailureReasoning != "" {
		fmt.Printf("    • Sizing note: %s\n", report.Sizing.FailureReasoning)
	}

	htmlReportPath := strings.TrimSuffix(reportPath, ".json") + ".html"
	fmt.Printf("\n  View full report:\n    %s\n\n", htmlReportPath)
	fmt.Println("══════════════════════════════════════════════════════════════")
	fmt.Println()
}

func updateConfigWithTargetAndWorkflow(configFilePath string, v *viper.Viper, target *parsedConnInfo, workflow string) {
	// Read the existing config file content
	data, err := os.ReadFile(configFilePath)
	if err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	content := string(data)

	// The config was generated from the offline-migration.yaml template which already has
	// target and export-data/import-data sections with placeholder values.
	// We do in-place replacements on those sections.

	// --- Target replacements ---
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-host: 127.0.0.1", fmt.Sprintf("db-host: %s", target.Host))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-port: 5433", fmt.Sprintf("db-port: %d", target.Port))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-name: yugabyte", fmt.Sprintf("db-name: %s", target.DBName))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-user: test_user", fmt.Sprintf("db-user: %s", target.User))
	if target.Password != "" {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"db-password: test_password", fmt.Sprintf("db-password: '%s'", strings.ReplaceAll(target.Password, "'", "''")))
	} else {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"  db-password: test_password", "  # db-password: <password>  # Or set TARGET_DB_PASSWORD env var")
	}

	// --- Workflow: for offline migration, the template already has the correct export-type ---
	// For non-offline workflows, we would need to change export-type and add extra sections.
	// For the POC, offline is the primary workflow.
	switch workflow {
	case "offline":
		// Template already has export-type: snapshot-only — nothing to change
	case "live", "live-fall-back", "live-fall-forward":
		// Change export-type from snapshot-only to snapshot-and-changes
		content = strings.Replace(content, "export-type: snapshot-only", "export-type: snapshot-and-changes", 1)
	}

	if err := os.WriteFile(configFilePath, []byte(content), 0644); err != nil {
		utils.ErrExit("failed to update config file: %v", err)
	}
}

func titleCase(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func printStartMigrationNextSteps(configFilePath string, v *viper.Viper, workflow string) {
	fmt.Println()
	fmt.Println("══════════════════════════════════════════════════════════════")
	fmt.Println()
	fmt.Println("  Next steps:")
	fmt.Println()

	step := 1

	// Check if permissions need granting
	sourceDBType := v.GetString("source.db-type")
	if sourceDBType == "postgresql" && (workflow == "live" || workflow == "live-fall-back" || workflow == "live-fall-forward") {
		sourceHost := v.GetString("source.db-host")
		sourceDBName := v.GetString("source.db-name")
		sourceUser := v.GetString("source.db-user")

		fmt.Printf("  %d. Grant permissions on your source database for live migration:\n\n", step)
		fmt.Printf("     psql -h %s -d %s -U %s \\\n", sourceHost, sourceDBName, sourceUser)
		fmt.Printf("       -f /opt/yb-voyager/guardrails-scripts/yb-voyager-pg-grant-migration-permissions.sql\n\n")
		step++
	}

	fmt.Printf("  %d. Export schema:\n", step)
	fmt.Printf("     yb-voyager export schema --config-file %s\n\n", configFilePath)

	printTip(configFilePath)
}
