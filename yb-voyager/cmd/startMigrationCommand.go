/*
Copyright (c) YugabyteDB, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cmd

import (
	"encoding/json"
	"fmt"
	"math"
	"os"
	"path/filepath"
	"strings"

	"github.com/charmbracelet/huh"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/yugabyte/yb-voyager/yb-voyager/src/utils"
)

var startMigrationCmd = &cobra.Command{
	Use:   "start-migration",
	Short: "Set up target database and migration workflow",
	Long: `Set up target database connection and select migration workflow.

This command should be run after assess-migration has completed. It will:
  - Display the assessment summary
  - Prompt for target YugabyteDB connection details
  - Let you choose a migration workflow (offline, live, etc.)
  - Update the config file with the target and workflow settings`,

	Run: func(cmd *cobra.Command, args []string) {
		runStartMigration()
	},
}

var startMigrationConfigFile string
var targetConnStringFlag string
var migrationWorkflowFlag string

func init() {
	rootCmd.AddCommand(startMigrationCmd)
	startMigrationCmd.Flags().StringVarP(&startMigrationConfigFile, "config-file", "c", "",
		"path to the config file generated by 'yb-voyager init'")
	startMigrationCmd.MarkFlagRequired("config-file")
	startMigrationCmd.Flags().StringVar(&targetConnStringFlag, "target-db-connection-string", "",
		"target YugabyteDB connection string (e.g. postgresql://yugabyte:yugabyte@host:5433/dbname). If provided, skips the interactive prompt.")
	startMigrationCmd.Flags().StringVar(&migrationWorkflowFlag, "workflow", "",
		"migration workflow: offline, live, live-fall-back, live-fall-forward. If provided, skips the interactive prompt.")
}

func runStartMigration() {
	// Resolve config file path
	var err error
	startMigrationConfigFile, err = filepath.Abs(startMigrationConfigFile)
	if err != nil {
		utils.ErrExit("failed to resolve config file path: %v", err)
	}

	if !utils.FileOrFolderExists(startMigrationConfigFile) {
		utils.ErrExit("config file not found: %s\nRun 'yb-voyager init' first to create a migration project.", startMigrationConfigFile)
	}

	// Load config to read source details and export-dir
	v := viper.New()
	v.SetConfigType("yaml")
	v.SetConfigFile(startMigrationConfigFile)
	if err := v.ReadInConfig(); err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	exportDirPath := v.GetString("export-dir")
	if exportDirPath == "" {
		utils.ErrExit("export-dir not set in config file: %s", startMigrationConfigFile)
	}

	sourceDBType := v.GetString("source.db-type")
	sourceHost := v.GetString("source.db-host")
	sourcePort := v.GetInt("source.db-port")
	sourceDBName := v.GetString("source.db-name")

	// Check if assessment has been run
	assessmentReportPath := filepath.Join(exportDirPath, "assessment", "reports",
		fmt.Sprintf("%s.json", ASSESSMENT_FILE_NAME))

	assessmentDone := utils.FileOrFolderExists(assessmentReportPath)

	if !assessmentDone {
		fmt.Println()
		fmt.Println(color.YellowString("  Warning: Assessment has not been run yet."))
		fmt.Println(color.YellowString("  It is recommended to run 'yb-voyager assess-migration' before starting migration."))
		fmt.Println()

		var proceed bool
		err := huh.NewConfirm().
			Title("Would you like to proceed without assessment?").
			Value(&proceed).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
		if !proceed {
			fmt.Println("\n  Run assessment first:")
			fmt.Printf("  yb-voyager assess-migration --config-file %s\n\n", startMigrationConfigFile)
			return
		}
	}

	// --- Target connection ---
	var targetParsed *parsedConnInfo
	if targetConnStringFlag != "" {
		// Non-interactive: use flag value
		targetParsed = parseAndValidateTarget(targetConnStringFlag)
	} else {
		// Interactive prompt
		fmt.Println("Before proceeding:")
		fmt.Println("  1. Ensure your target YugabyteDB cluster is created and running.")
		fmt.Println("  2. Create a database on the target cluster.")
		fmt.Println("  3. Create a superuser: CREATE USER ybvoyager SUPERUSER PASSWORD 'password';")
		fmt.Println()

		var targetConnString string
		for {
			err := huh.NewInput().
				Title("Enter the connection string for your target YugabyteDB").
				Description("Format: postgresql://user:password@host:5433/dbname").
				Placeholder("postgresql://yugabyte:yugabyte@localhost:5433/yugabyte").
				Value(&targetConnString).
				Run()
			if err != nil {
				utils.ErrExit("prompt failed: %v", err)
			}

			targetConnString = strings.TrimSpace(targetConnString)
			if targetConnString == "" {
				fmt.Println(color.RedString("  Target connection string is required."))
				continue
			}

			var parseErr error
			targetParsed, parseErr = parsePostgresConnString(targetConnString)
			if parseErr != nil {
				fmt.Println(color.RedString("  ✗ Invalid connection string: %v", parseErr))
				fmt.Println()
				continue
			}

			if err := validatePostgresConnection(targetConnString); err != nil {
				fmt.Println(color.RedString("  ✗ Connection failed: %v", err))
				fmt.Println()

				var retry bool
				huh.NewConfirm().
					Title("Would you like to try again?").
					Value(&retry).
					Run()
				if !retry {
					utils.ErrExit("Target connection is required to proceed.")
				}
				continue
			}
			break
		}
	}

	// --- Workflow selection ---
	var workflow string
	if migrationWorkflowFlag != "" {
		workflow = migrationWorkflowFlag
		validWorkflows := []string{"offline", "live", "live-fall-back", "live-fall-forward"}
		valid := false
		for _, w := range validWorkflows {
			if workflow == w {
				valid = true
				break
			}
		}
		if !valid {
			utils.ErrExit("invalid workflow %q. Must be one of: offline, live, live-fall-back, live-fall-forward", workflow)
		}
	} else {
		err = huh.NewSelect[string]().
			Title("Select your data migration workflow").
			Options(
				huh.NewOption("Offline — One-time snapshot; requires downtime", "offline"),
				huh.NewOption("Live — Minimal downtime using change data capture", "live"),
				huh.NewOption("Live with fall-back — Can switch back to source if needed", "live-fall-back"),
				huh.NewOption("Live with fall-forward — Can switch to a source-replica if needed", "live-fall-forward"),
			).
			Value(&workflow).
			Run()
		if err != nil {
			utils.ErrExit("prompt failed: %v", err)
		}
	}

	// Update config file with target details and workflow
	updateConfigWithTargetAndWorkflow(startMigrationConfigFile, v, targetParsed, workflow)

	// Print the status box with all gathered info
	printStartMigrationStatusBox(sourceDBType, sourceHost, sourcePort, sourceDBName,
		assessmentDone, assessmentReportPath, targetParsed, workflow, startMigrationConfigFile)

	printStartMigrationNextSteps(startMigrationConfigFile, v, workflow)
}

// parseAndValidateTarget parses and validates a target connection string provided via flag.
func parseAndValidateTarget(connStr string) *parsedConnInfo {
	connStr = strings.TrimSpace(connStr)
	parsed, err := parsePostgresConnString(connStr)
	if err != nil {
		utils.ErrExit("Invalid target connection string: %v", err)
	}
	if err := validatePostgresConnection(connStr); err != nil {
		utils.ErrExit("Target connection failed: %v", err)
	}
	return parsed
}

// printStartMigrationStatusBox prints the consolidated "Start Migration" box
// with source, assessment, target, workflow info and checkmarks.
func printStartMigrationStatusBox(
	dbType, host string, port int, dbName string,
	assessmentDone bool, assessmentReportPath string,
	target *parsedConnInfo, workflow, configFilePath string,
) {
	kw := 13 // key width for alignment

	var lines []string

	// Source
	if dbType != "" {
		lines = append(lines, formatKeyValue("Source:", fmt.Sprintf("%s @ %s:%d/%s", titleCase(dbType), host, port, dbName), kw))
	}

	// Assessment
	if assessmentDone {
		assessLine := successStyle.Render("✓ completed")
		sizingInfo := loadAssessmentSizing(assessmentReportPath)
		if sizingInfo != "" {
			assessLine += "\n" + strings.Repeat(" ", kw+1) + sizingInfo
		}
		htmlReportPath := strings.TrimSuffix(assessmentReportPath, ".json") + ".html"
		assessLine += "\n" + strings.Repeat(" ", kw+1) + dimStyle.Render("Report: "+displayPath(htmlReportPath))
		lines = append(lines, formatKeyValue("Assessment:", assessLine, kw))
	} else {
		lines = append(lines, formatKeyValue("Assessment:", warnStyle.Render("not yet run"), kw))
	}

	// Target
	targetLine := fmt.Sprintf("YugabyteDB @ %s:%d/%s", target.Host, target.Port, target.DBName)
	lines = append(lines, formatKeyValue("Target:", targetLine, kw))

	// Workflow
	workflowDisplay := workflowDisplayName(workflow)
	lines = append(lines, formatKeyValue("Workflow:", workflowDisplay, kw))

	lines = append(lines, "")
	lines = append(lines, successLine("Connected to target database"))
	lines = append(lines, successLine("Updated config  "+dimStyle.Render(displayPath(configFilePath))))

	printSection("Start Migration", lines...)
	fmt.Println()
}

// loadAssessmentSizing reads the assessment report and returns a short sizing summary string.
func loadAssessmentSizing(reportPath string) string {
	data, err := os.ReadFile(reportPath)
	if err != nil {
		return ""
	}
	var report AssessmentReport
	if err := json.Unmarshal(data, &report); err != nil {
		return ""
	}
	if report.Sizing == nil {
		return ""
	}
	sr := report.Sizing.SizingRecommendation
	result := fmt.Sprintf("%.0f nodes, %d vCPU / %d GB each recommended",
		math.Ceil(sr.NumNodes), sr.VCPUsPerInstance, sr.MemoryPerInstance)
	if report.Sizing.FailureReasoning != "" {
		result += " (" + report.Sizing.FailureReasoning + ")"
	}
	return result
}

// workflowDisplayName returns a human-readable name for a workflow identifier.
func workflowDisplayName(workflow string) string {
	switch workflow {
	case "offline":
		return "Offline (snapshot)"
	case "live":
		return "Live (CDC)"
	case "live-fall-back":
		return "Live with fall-back"
	case "live-fall-forward":
		return "Live with fall-forward"
	default:
		return titleCase(workflow)
	}
}

func updateConfigWithTargetAndWorkflow(configFilePath string, v *viper.Viper, target *parsedConnInfo, workflow string) {
	// Read the existing config file content
	data, err := os.ReadFile(configFilePath)
	if err != nil {
		utils.ErrExit("failed to read config file: %v", err)
	}

	content := string(data)

	// The config was generated from the offline-migration.yaml template which already has
	// target and export-data/import-data sections with placeholder values.
	// We do in-place replacements on those sections.

	// --- Target replacements ---
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-host: 127.0.0.1", fmt.Sprintf("db-host: %s", target.Host))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-port: 5433", fmt.Sprintf("db-port: %d", target.Port))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-name: yugabyte", fmt.Sprintf("db-name: %s", target.DBName))
	content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
		"db-user: test_user", fmt.Sprintf("db-user: %s", target.User))
	if target.Password != "" {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"db-password: test_password", fmt.Sprintf("db-password: '%s'", strings.ReplaceAll(target.Password, "'", "''")))
	} else {
		content = replaceInSection(content, "Target Database Configuration", "Assess Migration Configuration",
			"  db-password: test_password", "  # db-password: <password>  # Or set TARGET_DB_PASSWORD env var")
	}

	// --- Workflow: for offline migration, the template already has the correct export-type ---
	// For non-offline workflows, we would need to change export-type and add extra sections.
	// For the POC, offline is the primary workflow.
	switch workflow {
	case "offline":
		// Template already has export-type: snapshot-only — nothing to change
	case "live", "live-fall-back", "live-fall-forward":
		// Change export-type from snapshot-only to snapshot-and-changes
		content = strings.Replace(content, "export-type: snapshot-only", "export-type: snapshot-and-changes", 1)
	}

	if err := os.WriteFile(configFilePath, []byte(content), 0644); err != nil {
		utils.ErrExit("failed to update config file: %v", err)
	}
}

func titleCase(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func printStartMigrationNextSteps(configFilePath string, v *viper.Viper, workflow string) {
	var lines []string

	step := 1

	// Check if permissions need granting
	sourceDBType := v.GetString("source.db-type")
	if sourceDBType == "postgresql" && (workflow == "live" || workflow == "live-fall-back" || workflow == "live-fall-forward") {
		sourceHost := v.GetString("source.db-host")
		sourceDBName := v.GetString("source.db-name")
		sourceUser := v.GetString("source.db-user")

		lines = append(lines, fmt.Sprintf("%d. Grant permissions for live migration:", step))
		lines = append(lines, "")
		lines = append(lines, cmdStyle.Render(fmt.Sprintf("  psql -h %s -d %s -U %s \\\n    -f /opt/yb-voyager/guardrails-scripts/yb-voyager-pg-grant-migration-permissions.sql",
			sourceHost, sourceDBName, sourceUser)))
		lines = append(lines, "")
		step++
	}

	if step == 1 {
		lines = append(lines, "Export the schema from your source database:")
	} else {
		lines = append(lines, fmt.Sprintf("%d. Export schema:", step))
	}
	lines = append(lines, "")
	lines = append(lines, cmdStyle.Render(fmt.Sprintf("  yb-voyager export schema \\\n    --config-file %s",
		displayPath(configFilePath))))

	printSection("What's Next", lines...)
	fmt.Println()
}
