-- Unsupported Datatypes
CREATE TABLE parent_table (
    id SERIAL PRIMARY KEY,
    common_column1 TEXT,
    common_column2 INTEGER
);

CREATE TABLE child_table (
    specific_column1 DATE
) INHERITS (parent_table);

CREATE TABLE Mixed_Data_Types_Table1 (
    id SERIAL PRIMARY KEY,
    point_data POINT,
    snapshot_data TXID_SNAPSHOT,
    lseg_data LSEG,
    box_data BOX
);

CREATE TABLE Mixed_Data_Types_Table2 (
    id SERIAL PRIMARY KEY,
    lsn_data PG_LSN,
    lseg_data LSEG,
    path_data PATH
);

-- GIST Index on point_data column
CREATE INDEX idx_point_data ON Mixed_Data_Types_Table1 USING GIST (point_data);

-- GIST Index on box_data column
CREATE INDEX idx_box_data ON Mixed_Data_Types_Table1 USING GIST (box_data);

CREATE INDEX idx_box_data_brin ON public.Mixed_Data_Types_Table1 USING BRIN (box_data);

CREATE INDEX idx_box_data_spgist ON schema2.Mixed_Data_Types_Table1 USING SPGIST (box_data);

CREATE TABLE orders2 (
    id SERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE DEFERRABLE, --unique constraint deferrable test
    status VARCHAR(50) NOT NULL,
    shipped_date DATE
);

CREATE OR REPLACE FUNCTION prevent_update_shipped_without_date()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' AND NEW.status = 'shipped' AND NEW.shipped_date IS NULL THEN
        RAISE EXCEPTION 'Cannot update status to shipped without setting shipped_date';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create a Constraint Trigger
CREATE CONSTRAINT TRIGGER enforce_shipped_date_constraint
AFTER UPDATE ON orders2
FOR EACH ROW
WHEN (NEW.status = 'shipped' AND NEW.shipped_date IS NULL)
EXECUTE FUNCTION prevent_update_shipped_without_date();

-- Stored Generated Column
CREATE TABLE employees2 (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    full_name VARCHAR(101) GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED,
    Department varchar(50)
);

--For the ALTER TABLE ADD PK on partitioned DDL in schema
CREATE TABLE sales_region (id int, amount int, branch text, region text, PRIMARY KEY(id, region)) PARTITION BY LIST (region);
CREATE TABLE Boston PARTITION OF sales_region FOR VALUES IN ('Boston');
CREATE TABLE London PARTITION OF sales_region FOR VALUES IN ('London');
CREATE TABLE Sydney PARTITION OF sales_region FOR VALUES IN ('Sydney');

--For exclusion constraints
CREATE TABLE public.test_exclude_basic (
    id integer, 
    name text,
    address text
);
ALTER TABLE ONLY public.test_exclude_basic
    ADD CONSTRAINT no_same_name_address EXCLUDE USING btree (name WITH =, address WITH =);


CREATE TABLE test_xml_type(id int, data xml);

INSERT INTO test_xml_type values(1,'<person>
<name>ABC</name>
<age>34</age>
</person>');

INSERT INTO test_xml_type values(2,'<person>
<name>XYZ</name>
<age>36</age>
</person>');


CREATE ROLE test_policy;

CREATE POLICY policy_test_report ON test_xml_type TO test_policy USING (true);

CREATE POLICY policy_test_fine ON public.test_exclude_basic FOR ALL TO PUBLIC USING (id % 2 = 1);

CREATE POLICY policy_test_fine_2 ON public.employees2  USING (id NOT IN (12,123,41241));

CREATE VIEW sales_employees as
select id, first_name,
last_name, full_name
from employees2 where Department = 'sales'
WITH CHECK OPTION;


CREATE TABLE public.test_jsonb (
    id integer,
    data jsonb,
	data2 text
);

CREATE TABLE public.inet_type (
    id integer,
    data inet
);

CREATE EXTENSION citext;
CREATE TABLE public.citext_type (
    id integer,
    data public.citext
);

CREATE TABLE public.documents (
    id integer NOT NULL,
    title_tsvector tsvector,
    content_tsvector tsvector,
    list_of_sections text[]
);

CREATE TABLE public.ts_query_table (
    id int generated by default as identity,
    query tsquery
);

--normal indexes on column with types not supported
CREATE INDEX tsvector_idx ON public.documents  (title_tsvector, id);

CREATE INDEX idx_array ON public.documents (list_of_sections);

CREATE INDEX tsquery_idx ON public.ts_query_table (query);

CREATE INDEX idx_citext ON public.citext_type USING btree (data);

CREATE INDEX idx_citext1 ON public.citext_type USING btree (lower(data));

CREATE INDEX idx_citext2 ON public.citext_type USING btree ((data::text));

CREATE INDEX idx_inet ON public.inet_type USING btree (data);

CREATE INDEX idx_inet1 ON public.inet_type USING btree ((data::text));

CREATE INDEX idx_json ON public.test_jsonb (data);

-- expression index casting to types not supported
CREATE INDEX idx_json2 ON public.test_jsonb ((data2::jsonb)); 

-- valid case
create index idx_valid on public.test_jsonb ((data::text)); 


CREATE TYPE public.address_type AS (     
    street VARCHAR(100),
    city VARCHAR(50),
    state VARCHAR(50),
    zip_code VARCHAR(10)
);

CREATE EXTENSION lo;
--other misc types
create table public.combined_tbl (
	id int, 
	c cidr, 
	maddr macaddr, 
	maddr8 macaddr8,
	lsn pg_lsn, 
    inds3 INTERVAL DAY TO SECOND(3),
    d daterange,
	bitt bit (13),
	bittv bit varying(15) UNIQUE,
    address address_type,
    raster lo,
    arr_enum enum_kind[],
    PRIMARY KEY (id, arr_enum)
);

ALTER TABLE public.combined_tbl 
        ADD CONSTRAINT uk UNIQUE(lsn);

CREATE index idx1 on public.combined_tbl (c);

CREATE index idx2 on public.combined_tbl (maddr);

CREATE index idx3 on public.combined_tbl (maddr8);

CREATE index idx4 on public.combined_tbl (lsn);

CREATE INDEX idx5 on public.combined_tbl (bitt);

CREATE INDEX idx6 on public.combined_tbl (bittv);

CREATE INDEX idx7 on public.combined_tbl (address);

CREATE INDEX idx8 on public.combined_tbl (d);

CREATE INDEX idx9 on public.combined_tbl (inds3);

CREATE UNLOGGED TABLE tbl_unlogged (id int, val text);

CREATE OR REPLACE FUNCTION public.check_sales_region()
RETURNS TRIGGER AS $$
BEGIN

    IF NEW.amount < 0 THEN
        RAISE EXCEPTION 'Amount cannot be negative';
    END IF;

    IF NEW.branch IS NULL OR NEW.branch = '' THEN
        RAISE EXCEPTION 'Branch name cannot be null or empty';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_sales_region_insert_update
BEFORE INSERT OR UPDATE ON public.sales_region
FOR EACH ROW
EXECUTE FUNCTION public.check_sales_region();


 CREATE TABLE public.ordersentry (
    order_id SERIAL PRIMARY KEY,
    customer_name TEXT NOT NULL,
    product_name TEXT NOT NULL,
    quantity INT NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    processed_at timestamp
);

INSERT INTO public.ordersentry (customer_name, product_name, quantity, price)
VALUES
    ('Alice', 'Laptop', 1, 1200.00),
    ('Bob', 'Smartphone', 2, 800.00),
    ('Charlie', 'Tablet', 1, 500.00);

CREATE VIEW public.ordersentry_view AS
SELECT
    order_id,
    customer_name,
    product_name,
    quantity,
    price,
    xmlelement(
        name "OrderDetails",
        xmlelement(name "Customer", customer_name),
        xmlelement(name "Product", product_name),
        xmlelement(name "Quantity", quantity),
        xmlelement(name "TotalPrice", price * quantity)
    ) AS order_xml,
    xmlconcat(
        xmlelement(name "Customer", customer_name),
        xmlelement(name "Product", product_name)
    ) AS summary_xml,
    pg_try_advisory_lock(hashtext(customer_name || product_name)) AS lock_acquired,
    ctid AS row_ctid,
    xmin AS transaction_id
FROM
    ordersentry;

CREATE OR REPLACE FUNCTION process_order(orderid INT) RETURNS VOID AS $$
DECLARE
    lock_acquired BOOLEAN;
BEGIN
    lock_acquired := pg_try_advisory_lock(orderid); -- not able to report this as it is an assignment statement TODO: fix when support this 

    IF NOT lock_acquired THEN
        RAISE EXCEPTION 'Order % already being processed by another session', orderid;
    END IF;

    UPDATE orders
    SET processed_at = NOW()
    WHERE orders.order_id = orderid;

    RAISE NOTICE 'Order % processed successfully', orderid;

    PERFORM pg_advisory_unlock(orderid);
END;
$$ LANGUAGE plpgsql;

select process_order(1);

-- In PG migration from pg_dump the function parameters and return will never have the %TYPE syntax, instead they have the actual type in the DDLs
-- e.g. for the below function this will be the export one `CREATE FUNCTION public.process_combined_tbl(p_id integer, p_c cidr, p_bitt bit, p_inds3 interval) RETURNS macaddr`
CREATE OR REPLACE FUNCTION public.process_combined_tbl(
    p_id public.combined_tbl.id%TYPE,        
    p_c public.combined_tbl.c%TYPE,          
    p_bitt public.combined_tbl.bitt%TYPE,    
    p_inds3 public.combined_tbl.inds3%TYPE  
)
RETURNS public.combined_tbl.maddr%TYPE AS  
$$
DECLARE
    v_maddr public.combined_tbl.maddr%TYPE;   
BEGIN
    -- Example logic: Assigning local variable using passed-in parameter
    v_maddr := p_c::text;  -- Example conversion (cidr to macaddr), just for illustration

    -- Processing the passed parameters
    RAISE NOTICE 'Processing: ID = %, CIDR = %, BIT = %, Interval = %, MAC = %',
        p_id, p_c, p_bitt, p_inds3, v_maddr;

    -- Returning a value of the macaddr type (this could be more meaningful logic)
    RETURN v_maddr;  -- Returning a macaddr value
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE public.update_combined_tbl_data(
    p_id public.combined_tbl.id%TYPE,           
    p_c public.combined_tbl.c%TYPE,             
    p_bitt public.combined_tbl.bitt%TYPE,       
    p_d public.combined_tbl.d%TYPE              
)
AS
$$
DECLARE
    v_new_mac public.combined_tbl.maddr%TYPE;   
BEGIN
    -- Example: Using a local variable to store a macaddr value (for illustration)
    v_new_mac := '00:14:22:01:23:45'::macaddr;

    -- Updating the table with provided parameters
    UPDATE public.combined_tbl
    SET 
        c = p_c,              -- Updating cidr type column
        bitt = p_bitt,        -- Updating bit column
        d = p_d,              -- Updating daterange column
        maddr = v_new_mac     -- Using the local macaddr variable in update
    WHERE id = p_id;

    RAISE NOTICE 'Updated record with ID: %, CIDR: %, BIT: %, Date range: %', 
        p_id, p_c, p_bitt, p_d;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER t_raster BEFORE UPDATE OR DELETE ON public.combined_tbl
    FOR EACH ROW EXECUTE FUNCTION lo_manage(raster);

CREATE OR REPLACE FUNCTION public.manage_large_object(loid OID) RETURNS VOID AS $$
BEGIN
    IF loid IS NOT NULL THEN
        -- Unlink the large object to free up storage
        PERFORM lo_unlink(loid);
    END IF;
END;
$$ LANGUAGE plpgsql;