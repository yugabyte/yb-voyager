-- Unsupported Datatypes
CREATE TABLE parent_table (
    id SERIAL PRIMARY KEY,
    common_column1 TEXT,
    common_column2 INTEGER
);

CREATE TABLE child_table (
    specific_column1 DATE
) INHERITS (parent_table);

CREATE TABLE Mixed_Data_Types_Table1 (
    id SERIAL PRIMARY KEY,
    point_data POINT,
    snapshot_data TXID_SNAPSHOT,
    lseg_data LSEG,
    box_data BOX
);

CREATE TABLE Mixed_Data_Types_Table2 (
    id SERIAL PRIMARY KEY,
    lsn_data PG_LSN,
    lseg_data LSEG,
    path_data PATH
);

CREATE TABLE int_multirange_table (
    id SERIAL PRIMARY KEY,
    value_ranges int4multirange
);

CREATE TABLE bigint_multirange_table (
    id SERIAL PRIMARY KEY,
    value_ranges int8multirange
);

CREATE TABLE numeric_multirange_table (
    id SERIAL PRIMARY KEY,
    price_ranges nummultirange
);

CREATE TABLE timestamp_multirange_table (
    id SERIAL PRIMARY KEY,
    event_times tsmultirange
);

CREATE TABLE timestamptz_multirange_table (
    id SERIAL PRIMARY KEY,
    global_event_times tstzmultirange
);

CREATE TABLE date_multirange_table (
    id SERIAL PRIMARY KEY,
    project_dates datemultirange
);

CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE vector_table (
    id SERIAL PRIMARY KEY,
    vector_data public.vector(10)
);

-- Unsupported Extensions
CREATE EXTENSION IF NOT EXISTS plpython3u;
CREATE EXTENSION IF NOT EXISTS plperl;
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS pglogical;


-- GIST Index on point_data column
CREATE INDEX idx_point_data ON Mixed_Data_Types_Table1 USING GIST (point_data);

-- GIST Index on box_data column
CREATE INDEX idx_box_data ON Mixed_Data_Types_Table1 USING GIST (box_data);

CREATE INDEX idx_box_data_brin ON public.Mixed_Data_Types_Table1 USING BRIN (box_data);

CREATE INDEX idx_box_data_spgist ON schema2.Mixed_Data_Types_Table1 USING SPGIST (box_data);

CREATE TABLE orders2 (
    id SERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE DEFERRABLE, --unique constraint deferrable test
    status VARCHAR(50) NOT NULL,
    shipped_date DATE
);

CREATE INDEX idx_orders_shipped_date on public.orders2 (shipped_date);


CREATE OR REPLACE FUNCTION prevent_update_shipped_without_date()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' AND NEW.status = 'shipped' AND NEW.shipped_date IS NULL THEN
        RAISE EXCEPTION 'Cannot update status to shipped without setting shipped_date';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create a Constraint Trigger
CREATE CONSTRAINT TRIGGER enforce_shipped_date_constraint
AFTER UPDATE ON orders2
FOR EACH ROW
WHEN (NEW.status = 'shipped' AND NEW.shipped_date IS NULL)
EXECUTE FUNCTION prevent_update_shipped_without_date();

-- Stored Generated Column
CREATE TABLE employees2 (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    full_name VARCHAR(101) GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED,
    Department varchar(50)
);

--For the ALTER TABLE ADD PK on partitioned DDL in schema
CREATE TABLE sales_region (id int, amount int, branch text, region text, PRIMARY KEY(id, region)) PARTITION BY LIST (region);
CREATE TABLE Boston PARTITION OF sales_region FOR VALUES IN ('Boston');
CREATE TABLE London PARTITION OF sales_region FOR VALUES IN ('London');
CREATE TABLE Sydney PARTITION OF sales_region FOR VALUES IN ('Sydney');

--For exclusion constraints
CREATE TABLE public.test_exclude_basic (
    id integer, 
    name text,
    address text
);
ALTER TABLE ONLY public.test_exclude_basic
    ADD CONSTRAINT no_same_name_address EXCLUDE USING btree (name WITH =, address WITH =);


CREATE TABLE test_xml_type(id int, data xml);

INSERT INTO test_xml_type values(1,'<person>
<name>ABC</name>
<age>34</age>
</person>');

INSERT INTO test_xml_type values(2,'<person>
<name>XYZ</name>
<age>36</age>
</person>');


CREATE ROLE test_policy;

CREATE POLICY policy_test_report ON test_xml_type TO test_policy USING (true);

CREATE POLICY policy_test_fine ON public.test_exclude_basic FOR ALL TO PUBLIC USING (id % 2 = 1);

CREATE POLICY policy_test_fine_2 ON public.employees2  USING (id NOT IN (12,123,41241));

CREATE VIEW sales_employees as
select id, first_name,
last_name, full_name
from employees2 where Department = 'sales'
WITH CHECK OPTION;


CREATE TABLE public.test_jsonb (
    id integer,
    data jsonb,
	data2 text,
    region text,
    FOREIGN KEY (id, region) REFERENCES sales_region(id, region)
);

CREATE TABLE public.inet_type (
    id integer,
    data inet
);

CREATE EXTENSION citext;
CREATE TABLE public.citext_type (
    id integer,
    data public.citext
);

CREATE TABLE public.documents (
    id integer NOT NULL,
    title_tsvector tsvector,
    content_tsvector tsvector,
    list_of_sections text[]
);

CREATE TABLE public.ts_query_table (
    id int generated by default as identity,
    query tsquery
);

--normal indexes on column with types not supported
CREATE INDEX tsvector_idx ON public.documents  (title_tsvector, id);

CREATE INDEX idx_array ON public.documents (list_of_sections);

CREATE INDEX tsquery_idx ON public.ts_query_table (query);

CREATE INDEX idx_citext ON public.citext_type USING btree (data);

CREATE INDEX idx_citext1 ON public.citext_type USING btree (lower(data));

CREATE INDEX idx_citext2 ON public.citext_type USING btree ((data::text));

CREATE INDEX idx_inet ON public.inet_type USING btree (data);

CREATE INDEX idx_inet1 ON public.inet_type USING btree ((data::text));

CREATE INDEX idx_json ON public.test_jsonb (data);

-- expression index casting to types not supported
CREATE INDEX idx_json2 ON public.test_jsonb ((data2::jsonb)); 

-- valid case
create index idx_valid on public.test_jsonb ((data::text)); 


CREATE TYPE public.address_type AS (     
    street VARCHAR(100),
    city VARCHAR(50),
    state VARCHAR(50),
    zip_code VARCHAR(10)
);

CREATE EXTENSION lo;

CREATE EXTENSION hstore;
--other misc types
create table public.combined_tbl (
	id int, 
	c cidr, 
	maddr macaddr, 
	maddr8 macaddr8,
	lsn pg_lsn, 
    inds3 INTERVAL DAY TO SECOND(3),
    d daterange,
	bitt bit (13),
	bittv bit varying(15) UNIQUE,
    address address_type,
    raster lo,
    arr_enum enum_kind[],
    data hstore,
    xml_data xml[],
    PRIMARY KEY (id, arr_enum)
);

ALTER TABLE public.combined_tbl 
        ADD CONSTRAINT uk UNIQUE(lsn);

CREATE index idx1 on public.combined_tbl (c);

CREATE index idx2 on public.combined_tbl (maddr);

CREATE index idx3 on public.combined_tbl (maddr8);

CREATE index idx4 on public.combined_tbl (lsn);

CREATE INDEX idx5 on public.combined_tbl (bitt);

CREATE INDEX idx6 on public.combined_tbl (bittv);

CREATE INDEX idx7 on public.combined_tbl (address);

CREATE INDEX idx8 on public.combined_tbl (d);

CREATE INDEX idx9 on public.combined_tbl (inds3);

CREATE UNLOGGED TABLE tbl_unlogged (id int, val text);

CREATE OR REPLACE FUNCTION public.check_sales_region()
RETURNS TRIGGER AS $$
BEGIN

    IF NEW.amount < 0 THEN
        RAISE EXCEPTION 'Amount cannot be negative';
    END IF;

    IF NEW.branch IS NULL OR NEW.branch = '' THEN
        RAISE EXCEPTION 'Branch name cannot be null or empty';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_sales_region_insert_update
BEFORE INSERT OR UPDATE ON public.sales_region
FOR EACH ROW
EXECUTE FUNCTION public.check_sales_region();


 CREATE TABLE public.ordersentry (
    order_id SERIAL PRIMARY KEY,
    customer_name TEXT NOT NULL,
    product_name TEXT NOT NULL,
    quantity INT NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    processed_at timestamp,
    r INT DEFAULT regexp_count('This is an example. Another example. Example is a common word.', 'example') -- regex functions in default
);

CREATE INDEX idx_ordersentry_processed_at on public.ordersentry (processed_at);

INSERT INTO public.ordersentry (customer_name, product_name, quantity, price)
VALUES
    ('Alice', 'Laptop', 1, 1200.00),
    ('Bob', 'Smartphone', 2, 800.00),
    ('Charlie', 'Tablet', 1, 500.00);

CREATE VIEW public.ordersentry_view AS
SELECT
    order_id,
    customer_name,
    product_name,
    quantity,
    price,
    xmlelement(
        name "OrderDetails",
        xmlelement(name "Customer", customer_name),
        xmlelement(name "Product", product_name),
        xmlelement(name "Quantity", quantity),
        xmlelement(name "TotalPrice", price * quantity)
    ) AS order_xml,
    xmlconcat(
        xmlelement(name "Customer", customer_name),
        xmlelement(name "Product", product_name)
    ) AS summary_xml,
    pg_try_advisory_lock(hashtext(customer_name || product_name)) AS lock_acquired,
    ctid AS row_ctid,
    xmin AS transaction_id
FROM
    ordersentry;

CREATE OR REPLACE FUNCTION process_order(orderid INT) RETURNS VOID AS $$
DECLARE
    lock_acquired BOOLEAN;
BEGIN
    lock_acquired := pg_try_advisory_lock(orderid); -- not able to report this as it is an assignment statement TODO: fix when support this 

    IF NOT lock_acquired THEN
        RAISE EXCEPTION 'Order % already being processed by another session', orderid;
    END IF;

    UPDATE orders
    SET processed_at = NOW()
    WHERE orders.order_id = orderid;

    RAISE NOTICE 'Order % processed successfully', orderid;

    PERFORM pg_advisory_unlock(orderid);
END;
$$ LANGUAGE plpgsql;

select process_order(1);

-- In PG migration from pg_dump the function parameters and return will never have the %TYPE syntax, instead they have the actual type in the DDLs
-- e.g. for the below function this will be the export one `CREATE FUNCTION public.process_combined_tbl(p_id integer, p_c cidr, p_bitt bit, p_inds3 interval) RETURNS macaddr`
CREATE OR REPLACE FUNCTION public.process_combined_tbl(
    p_id public.combined_tbl.id%TYPE,        
    p_c public.combined_tbl.c%TYPE,          
    p_bitt public.combined_tbl.bitt%TYPE,    
    p_inds3 public.combined_tbl.inds3%TYPE  
)
RETURNS public.combined_tbl.maddr%TYPE AS  
$$
DECLARE
    v_maddr public.combined_tbl.maddr%TYPE;   
BEGIN
    -- Example logic: Assigning local variable using passed-in parameter
    v_maddr := p_c::text;  -- Example conversion (cidr to macaddr), just for illustration

    -- Processing the passed parameters
    RAISE NOTICE 'Processing: ID = %, CIDR = %, BIT = %, Interval = %, MAC = %',
        p_id, p_c, p_bitt, p_inds3, v_maddr;

    -- Returning a value of the macaddr type (this could be more meaningful logic)
    RETURN v_maddr;  -- Returning a macaddr value
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE public.update_combined_tbl_data(
    p_id public.combined_tbl.id%TYPE,           
    p_c public.combined_tbl.c%TYPE,             
    p_bitt public.combined_tbl.bitt%TYPE,       
    p_d public.combined_tbl.d%TYPE              
)
AS
$$
DECLARE
    v_new_mac public.combined_tbl.maddr%TYPE;   
BEGIN
    -- Example: Using a local variable to store a macaddr value (for illustration)
    v_new_mac := '00:14:22:01:23:45'::macaddr;

    -- Updating the table with provided parameters
    UPDATE public.combined_tbl
    SET 
        c = p_c,              -- Updating cidr type column
        bitt = p_bitt,        -- Updating bit column
        d = p_d,              -- Updating daterange column
        maddr = v_new_mac     -- Using the local macaddr variable in update
    WHERE id = p_id;

    RAISE NOTICE 'Updated record with ID: %, CIDR: %, BIT: %, Date range: %', 
        p_id, p_c, p_bitt, p_d;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER t_raster BEFORE UPDATE OR DELETE ON public.combined_tbl
    FOR EACH ROW EXECUTE FUNCTION lo_manage(raster);

CREATE OR REPLACE FUNCTION public.manage_large_object(loid OID) RETURNS VOID AS $$
BEGIN
    IF loid IS NOT NULL THEN
        -- Unlink the large object to free up storage
        PERFORM lo_unlink(loid);
    END IF;
END;
$$ LANGUAGE plpgsql;

-- for FETCH .. WITH TIES
CREATE TABLE employeesForView (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    salary NUMERIC(10, 2) NOT NULL
);

CREATE VIEW top_employees_view AS SELECT * FROM (
			SELECT * FROM employeesForView
			ORDER BY salary DESC
			FETCH FIRST 2 ROWS WITH TIES
		) AS top_employees;

-- SECURITY INVOKER VIEW
CREATE TABLE public.employees (
    employee_id SERIAL PRIMARY KEY,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    department VARCHAR(50)
);

INSERT INTO public.employees (first_name, last_name, department)
VALUES
    ('Alice', 'Smith', 'HR'),
    ('Bob', 'Jones', 'Finance'),
    ('Charlie', 'Brown', 'IT'),
    ('Diana', 'Prince', 'HR'),
    ('Ethan', 'Hunt', 'Security');

CREATE VIEW public.view_explicit_security_invoker
WITH (security_invoker = true) AS
    SELECT employee_id, first_name
    FROM public.employees;

CREATE COLLATION schema2.ignore_accents (provider = icu, locale = 'und-u-ks-level1-kc-true', deterministic = false);

 CREATE COLLATION public.numeric (provider = icu, locale = 'en@colNumeric=yes');
-- Testing tables with unique nulls not distinct constraints

-- Control case
CREATE TABLE users_unique_nulls_distinct (
    id INTEGER PRIMARY KEY,
    email TEXT COMPRESSION pglz,
    UNIQUE (email)
);

CREATE TABLE users_unique_nulls_not_distinct (
    id INTEGER PRIMARY KEY,
    email TEXT,
    UNIQUE NULLS NOT DISTINCT (email)
);

CREATE TABLE sales_unique_nulls_not_distinct (
    store_id INT,
    product_id INT,
    sale_date DATE,
    UNIQUE NULLS NOT DISTINCT (store_id, product_id, sale_date)
);

CREATE TABLE sales_unique_nulls_not_distinct_alter (
	store_id INT,
	product_id INT,
	sale_date DATE
);

ALTER TABLE sales_unique_nulls_not_distinct_alter
	ADD CONSTRAINT sales_unique_nulls_not_distinct_alter_unique UNIQUE NULLS NOT DISTINCT (store_id, product_id, sale_date);

-- Create a unique index on a column with NULLs with the NULLS NOT DISTINCT option
CREATE TABLE users_unique_nulls_not_distinct_index (
    id INTEGER PRIMARY KEY,
    email TEXT
);

CREATE UNIQUE INDEX users_unique_nulls_not_distinct_index_email
    ON users_unique_nulls_not_distinct_index (email)
    NULLS NOT DISTINCT;


CREATE OR REPLACE FUNCTION insert_non_decimal()
RETURNS VOID AS $$
BEGIN
    -- Create a table for demonstration
    CREATE TEMP TABLE non_decimal_table (
        id SERIAL,
        binary_value INTEGER,
        octal_value INTEGER,
        hex_value INTEGER
    );
    SELECT 5678901234, 0x1527D27F2, 0o52237223762, 0b101010010011111010010011111110010;
    -- Insert values into the table
    --not reported as parser converted these values to decimal ones while giving parseTree
    INSERT INTO non_decimal_table (binary_value, octal_value, hex_value)
    VALUES (0b1010, 0o012, 0xA); -- Binary (10), Octal (10), Hexadecimal (10)

    RAISE NOTICE 'Row inserted with non-decimal integers.';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION asterisks(n int)
  RETURNS SETOF text
  LANGUAGE sql IMMUTABLE STRICT PARALLEL SAFE
BEGIN ATOMIC
SELECT repeat('*', g) FROM generate_series (1, n) g;
END;
-- BEGIN ATOMIC syntax is not working with regex parser we have for functions TODO: fix 

CREATE OR REPLACE FUNCTION asterisks1(n int)
  RETURNS text
  LANGUAGE sql IMMUTABLE STRICT PARALLEL SAFE
RETURN repeat('*', n);

CREATE OR REPLACE FUNCTION notify_and_insert()
RETURNS VOID AS $$
BEGIN
	LISTEN my_table_changes;
    INSERT INTO my_table (name) VALUES ('Charlie');
	NOTIFY my_table_changes, 'New row added with name: Charlie';
    PERFORM pg_notify('my_table_changes', 'New row added with name: Charlie');
	UNLISTEN my_table_changes;
END;
$$ LANGUAGE plpgsql;