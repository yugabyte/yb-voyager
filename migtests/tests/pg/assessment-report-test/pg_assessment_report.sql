-- Unsupported Datatypes
CREATE TABLE parent_table (
    id SERIAL PRIMARY KEY,
    common_column1 TEXT,
    common_column2 INTEGER
);

CREATE TABLE child_table (
    specific_column1 DATE
) INHERITS (parent_table);

CREATE TABLE Mixed_Data_Types_Table1 (
    id SERIAL PRIMARY KEY,
    point_data POINT,
    snapshot_data TXID_SNAPSHOT,
    lseg_data LSEG,
    box_data BOX
);

CREATE TABLE Mixed_Data_Types_Table2 (
    id SERIAL PRIMARY KEY,
    lsn_data PG_LSN,
    lseg_data LSEG,
    path_data PATH
);

-- GIST Index on point_data column
CREATE INDEX idx_point_data ON Mixed_Data_Types_Table1 USING GIST (point_data);

-- GIST Index on box_data column
CREATE INDEX idx_box_data ON Mixed_Data_Types_Table1 USING GIST (box_data);

CREATE INDEX idx_box_data_brin ON public.Mixed_Data_Types_Table1 USING BRIN (box_data);

CREATE INDEX idx_box_data_spgist ON schema2.Mixed_Data_Types_Table1 USING SPGIST (box_data);

CREATE TABLE orders2 (
    id SERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE DEFERRABLE, --unique constraint deferrable test
    status VARCHAR(50) NOT NULL,
    shipped_date DATE
);

CREATE OR REPLACE FUNCTION prevent_update_shipped_without_date()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' AND NEW.status = 'shipped' AND NEW.shipped_date IS NULL THEN
        RAISE EXCEPTION 'Cannot update status to shipped without setting shipped_date';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create a Constraint Trigger
CREATE CONSTRAINT TRIGGER enforce_shipped_date_constraint
AFTER UPDATE ON orders2
FOR EACH ROW
WHEN (NEW.status = 'shipped' AND NEW.shipped_date IS NULL)
EXECUTE FUNCTION prevent_update_shipped_without_date();

-- Stored Generated Column
CREATE TABLE employees2 (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    full_name VARCHAR(101) GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED,
    Department varchar(50)
);

--For the ALTER TABLE ADD PK on partitioned DDL in schema
CREATE TABLE sales_region (id int, amount int, branch text, region text, PRIMARY KEY(id, region)) PARTITION BY LIST (region);
CREATE TABLE Boston PARTITION OF sales_region FOR VALUES IN ('Boston');
CREATE TABLE London PARTITION OF sales_region FOR VALUES IN ('London');
CREATE TABLE Sydney PARTITION OF sales_region FOR VALUES IN ('Sydney');

--For exclusion constraints
CREATE TABLE public.test_exclude_basic (
    id integer, 
    name text,
    address text
);
ALTER TABLE ONLY public.test_exclude_basic
    ADD CONSTRAINT no_same_name_address EXCLUDE USING btree (name WITH =, address WITH =);


CREATE TABLE test_xml_type(id int, data xml);

INSERT INTO test_xml_type values(1,'<person>
<name>ABC</name>
<age>34</age>
</person>');

INSERT INTO test_xml_type values(2,'<person>
<name>XYZ</name>
<age>36</age>
</person>');


CREATE ROLE test_policy;

CREATE POLICY policy_test_report ON test_xml_type TO test_policy USING (true);

CREATE POLICY policy_test_fine ON public.test_exclude_basic FOR ALL TO PUBLIC USING (id % 2 = 1);

CREATE POLICY policy_test_fine_2 ON public.employees2  USING (id NOT IN (12,123,41241));

CREATE VIEW sales_employees as
select id, first_name,
last_name, full_name
from employees2 where Department = 'sales'
WITH CHECK OPTION;


CREATE TABLE public.test_jsonb (
    id integer,
    data jsonb,
	data2 text
);

CREATE TABLE public.inet_type (
    id integer,
    data inet
);

CREATE EXTENSION citext;
CREATE TABLE public.citext_type (
    id integer,
    data public.citext
);

CREATE TABLE public.documents (
    id integer NOT NULL,
    title_tsvector tsvector,
    content_tsvector tsvector,
    list_of_sections text[]
);

CREATE TABLE public.ts_query_table (
    id int generated by default as identity,
    query tsquery
);

--normal indexes on column with types not supported
CREATE INDEX tsvector_idx ON public.documents  (title_tsvector, id);

CREATE INDEX idx_array ON public.documents (list_of_sections);

CREATE INDEX tsquery_idx ON public.ts_query_table (query);

CREATE INDEX idx_citext ON public.citext_type USING btree (data);

CREATE INDEX idx_citext1 ON public.citext_type USING btree (lower(data));

CREATE INDEX idx_citext2 ON public.citext_type USING btree ((data::text));

CREATE INDEX idx_inet ON public.inet_type USING btree (data);

CREATE INDEX idx_inet1 ON public.inet_type USING btree ((data::text));

CREATE INDEX idx_json ON public.test_jsonb (data);

-- expression index casting to types not supported
CREATE INDEX idx_json2 ON public.test_jsonb ((data2::jsonb)); 

-- valid case
create index idx_valid on public.test_jsonb ((data::text)); 


CREATE TYPE public.address_type AS (     
    street VARCHAR(100),
    city VARCHAR(50),
    state VARCHAR(50),
    zip_code VARCHAR(10)
);

--other misc types
create table public.combined_tbl (
	id int, 
	c cidr, 
	maddr macaddr, 
	maddr8 macaddr8,
	lsn pg_lsn, 
	bitt bit (13),
	bittv bit varying(15),
    address address_type,
    arr_enum enum_kind[]
);

CREATE index idx1 on public.combined_tbl (c);

CREATE index idx2 on public.combined_tbl (maddr);

CREATE index idx3 on public.combined_tbl (maddr8);

CREATE index idx4 on public.combined_tbl (lsn);

CREATE INDEX idx5 on public.combined_tbl (bitt);

CREATE INDEX idx6 on public.combined_tbl (bittv);

CREATE INDEX idx7 on public.combined_tbl (address);

CREATE UNLOGGED TABLE tbl_unlogged (id int, val text);


CREATE OR REPLACE FUNCTION public.check_sales_region()
RETURNS TRIGGER AS $$
BEGIN

    IF NEW.amount < 0 THEN
        RAISE EXCEPTION 'Amount cannot be negative';
    END IF;

    IF NEW.branch IS NULL OR NEW.branch = '' THEN
        RAISE EXCEPTION 'Branch name cannot be null or empty';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_sales_region_insert_update
BEFORE INSERT OR UPDATE ON public.sales_region
FOR EACH ROW
EXECUTE FUNCTION public.check_sales_region();
