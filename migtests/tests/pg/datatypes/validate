#!/usr/bin/env python3

import common
import os
import yb
import collections
import re

def main():
	test_type_flags = common.valparser()
	
	migration_completed_checks_yb()

	if test_type_flags['ff_enabled'] == 'true':
		migration_completed_checks_ff()
	
	if test_type_flags['fb_enabled'] == 'true':
		migration_completed_checks_fb()

#=============================================================================

EXPECTED_ROW_COUNT = {
 	'num_types': 3,   
	'datatypes1': 3,  
	'datetime_type': 3, 
	'datatypes2': 3,
	'datetime_type2': 2, 
	'null_and_default' :2,
	'decimal_types': 3,
	'hstore_example': 26,
	'tsvector_table': 3,
	'enum_array_table': 3,
	'composite_types': 2,
	'composite_array_types': 2,
	'domain_types': 3,
	'domain_array_types': 3,
	'range_types': 3,
	'range_array_types': 3,
	'extension_types': 3,
	'extension_arrays': 3,
	'audit_log': 2
}

EXPECTED_SUM_OF_COLUMN = {
	'num_types': {
		'v1': '32621',
		'v2': '-3380617',
		'v3': '564312385451',
		'v4': '993.999',
		'v5': ['9992334.5429','9992334.54290'],
		'v6': '-$12,000,369.60'
	},
	'decimal_types': {
		'n1':'1865936917203721067473070692042057616523559824435284801786158802063081501757370781516738843414444000.095730002',
		'n2':'167981693608097436.14'
	},
}

EXPECTED_ENUM_VALUES = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
EXPECTED_BYTE_TYPE_VALUES = ['3031303130', '2d61626364', '34343538']

#Due to the large sized source database requirements all tables will come up as colocated for now
EXPECTED_COLOCATION_OF_TABLES = {
	'num_types': 't',   
	'datatypes1': 't',  
	'datetime_type': 't', 
	'datatypes2': 't',
	'datetime_type2': 't', 
	'null_and_default' : 't',
	'decimal_types': 't',
}

def migration_completed_checks_yb():
	print("Running tests on YB")
	yb.run_checks(migration_completed_checks)
	yb.run_checks(YB_specific_checks)

def migration_completed_checks_ff():
	print("Running tests on PG source replica")
	yb.run_checks(migration_completed_checks, db_type="source_replica")

def migration_completed_checks_fb():
	print("Running tests on PG source")
	yb.run_checks(migration_completed_checks, db_type="source")

def migration_completed_checks(tgt):
	table_list = tgt.get_table_names("public")
	print("table_list:", table_list)
	assert len(table_list) == 19

	got_row_count = tgt.row_count_of_all_tables("public")
	for table_name, row_count in EXPECTED_ROW_COUNT.items():
		print(f"table_name: {table_name}, row_count: {got_row_count[table_name]}")
		assert row_count == got_row_count[table_name]

	for table_name, column_names_with_sum in EXPECTED_SUM_OF_COLUMN.items():
		print(f"table_name: {table_name} ---- ")
		for column, sum in column_names_with_sum.items():
			col_sum = tgt.get_sum_of_column_of_table(table_name, column, "public")
			# YB returns .5429 and PG returns .54290. Thus this fails during string comparison
			# TODO Add proper handling for the case
			if column == 'v5' and table_name == 'num_types':
				expected_values = column_names_with_sum[column]
				assert str(col_sum) in expected_values
			else:
				assert str(col_sum) == sum
			print(f"column_name: {column}, sum: {col_sum}")

	distinct_values_enum_types = tgt.get_distinct_values_of_column_of_table("datatypes1", "enum_type", "public")
	print(f"distinct_enum_values:")
	for distinct_value in distinct_values_enum_types:
		print(f"{distinct_value}")
		assert distinct_value.lower() in EXPECTED_ENUM_VALUES

	distinct_values_bool_types = tgt.get_distinct_values_of_column_of_table("datatypes1", "bool_type", "public")
	print(f"distinct_bool_values:")
	for distinct_value in distinct_values_bool_types:
		print(f"{distinct_value}")
		assert distinct_value == 0 or distinct_value == 1

	print(f"distinct_bytea_values:")
	tgt.assert_distinct_values_of_col("datatypes1", "byte_type", "public", 
		transform_func=lambda x: x.hex(), expected_distinct_values=EXPECTED_BYTE_TYPE_VALUES)

	print(f"distinct_json_values:")
	tgt.assert_all_values_of_col("datatypes2", "v1", "public", 
		transform_func=str, expected_values=["{'key1': 'value1', 'key2': 'value2'}", "['a', 'b', 'c', 1, 2, 3]", None])

	print(f"distinct_bit10_values:")
	tgt.assert_distinct_values_of_col("datatypes2", "v2", "public", 
		transform_func=str, expected_distinct_values=['1001100101','0001010101','1001000101'])
	
	print(f"distinct_bit_varying_values:")
	expected_values = ['0001010101','0001010','00101010101010101010101010001010100101010101010101000']
	print(f"expected_values: {expected_values}")
	
	tgt.assert_distinct_values_of_col("datatypes2", "v5", "public", 
		None, expected_distinct_values=expected_values)

	print(f"distinct_int[]_values:")
	tgt.assert_distinct_values_of_col("datatypes2", "v3", "public", 
		expected_distinct_values=[[20000, 14600, 23500, 13250], None])

	print(f"distinct_text[]_values:")
	expected_text_mda_values = [[['â€œFDâ€'], ['act']], [['â€œFDâ€', 'â€œMFâ€'], ['â€œFDâ€', 'â€œPropertyâ€']], [['â€œFDâ€', 'â€œMFâ€'], ['act', 'two']]]
	tgt.assert_distinct_values_of_col("datatypes2", "v4", "public", 
		expected_distinct_values=expected_text_mda_values)

	print(f"distinct_ts_values:")
	tgt.assert_distinct_values_of_col("datetime_type2", "v1", "public", 
		transform_func=str, expected_distinct_values=['2022-11-01 15:55:58.091241', '2022-11-01 15:58:02'])
	
	print("null_and_default:")
	tgt.assert_all_values_of_col("null_and_default", "val", "public", expected_values=["testdefault", None])
	tgt.assert_all_values_of_col("null_and_default", "i", "public", expected_values=[10, None])
	tgt.assert_all_values_of_col("null_and_default", "b", "public", expected_values=[False, None])

	print("hstore_example:")
	expected_hstore_values = [
    '"key1"=>"value1", "key2"=>"value2"',
    '"a\\"b"=>"d\\"a"',
    None,
    '',
    '"key1"=>"value1", "key2"=>"value2"',
    '"key7"=>"value7", "key8"=>"123", "key9"=>"true"',
    '"weight"=>"11.2 ounces", "ISBN-13"=>"978-1449370000", "language"=>"English", "paperback"=>"243", "publisher"=>"postgresqltutorial.com"',
    '"f1"=>"1", "f2"=>"{\\"key1=value1, key2=value2\\"}"',
    '"json_field"=>"{\\"key1=value1, key2={\\"key1=value1, key2=value2\\"}\\"}"',
    '"{\\"key1=value1, key2=value2\\"}"=>"{\\"key1=value1, key2={\\"key1=value1, key2=value2\\"}\\"}"',
    '""=>"emptykey"',
    '"emptyvalue"=>""',
    '"longkey"=>"{}"'.format('x'*10000),
    '"ÐºÐ»ÑŽÑ‡"=>"Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"',
    '"emoji_ðŸ˜€"=>"ðŸ˜ŽðŸ”¥"',
    '"cafÃ©"=>"naÃ¯ve"',
    '"select"=>"statement"',
    '"dup"=>"first"',
    '"key with spaces"=>"value with spaces"',
    '" space_key "=>" space_value "',
    '"key\\"quote"=>"value\\"quote"',
    '"key\'single"=>"value\'single"',
    '"{\\"json_like_key\\":1}"=>"{\\"json_like_value\\":2}"',
	'"\\"{key1:value1,key2:value2}\\""=>"{\\"key1=value1, key2={\\"key1=value1, key2=value2\\"}\\"}"',
	'"\\"{\\"\\"key1\\"\\":\\"\\"value1\\"\\",\\"\\"key2\\"\\":\\"\\"value2\\"\\"}\\""=>"{\\"key1=value1, key2={\\"key1=value1, key2=value2\\"}\\"}"',
	'"key=,=>"=>"value\\\\n\\\\t"'

	]

	tgt.assert_distinct_values_of_col("hstore_example", "data", "public", expected_distinct_values=expected_hstore_values)

	print("tsvector_table:")
	expected_tsvector_titles = ['PostgreSQL Tutorial', 'Advanced SQL', 'Data Migration']
	tgt.assert_distinct_values_of_col("tsvector_table", "title", "public", expected_distinct_values=expected_tsvector_titles)

	print("enum_array_table:")
	# Get actual enum arrays and parse them from string representation to lists
	actual_enum_arrays = tgt.get_distinct_values_of_column_of_table("enum_array_table", "week_days", "public")
	print(f"actual_enum_arrays: {actual_enum_arrays}")
	
	# Parse string representations like '{mon,wed,fri}' into actual lists
	def parse_enum_array_string(array_str):
		if array_str is None:
			return None
		# Remove curly braces and split by comma
		return [item.strip().lower() for item in array_str.strip('{}').split(',')]
	
	parsed_actual_arrays = [parse_enum_array_string(arr) for arr in actual_enum_arrays]
	
	# Expected enum arrays as actual Python lists
	expected_enum_arrays = [['mon', 'wed', 'fri'], ['tue', 'thu'], ['sat', 'sun']]
	
	# Compare actual lists
	for expected_array in expected_enum_arrays:
		assert expected_array in parsed_actual_arrays, f"Expected {expected_array} not found in {parsed_actual_arrays}"

	print("composite_types:")
	expected_composite_types = ['(City1I,"Street 1I",1)', '(City2I,"Street 2I",2)']
	tgt.assert_distinct_values_of_col("composite_types", "address", "public", 
		transform_func=str, expected_distinct_values=expected_composite_types)

	print("composite_array_types:")
	expected_composite_array_types = [
		'{"(CityA1I,\\"StreetA 1I\\",1)","(CityB1I,\\"StreetB 1I\\",2)"}',
		'{"(CityA2I,\\"StreetA 2I\\",2)","(CityB2I,\\"StreetB 2I\\",3)"}'
	]
	tgt.assert_distinct_values_of_col("composite_array_types", "addresses", "public", 
		transform_func=str, expected_distinct_values=expected_composite_array_types)

	print("domain_types:")
	expected_ssn_values = ['001-00-0001', '002-00-0002', '003-00-0003']
	tgt.assert_distinct_values_of_col("domain_types", "ssn", "public", 
		transform_func=str, expected_distinct_values=expected_ssn_values)
	expected_email_values = ['user1@example.com', 'user2@example.com', 'user3@example.com']
	tgt.assert_distinct_values_of_col("domain_types", "email", "public", 
		transform_func=str, expected_distinct_values=expected_email_values)
	expected_rating_values = [1, 2, 3]
	tgt.assert_distinct_values_of_col("domain_types", "rating", "public", 
		expected_distinct_values=expected_rating_values)
	expected_prefs_values = ["{'theme': 'dark', 'version': '1'}", "{'theme': 'dark', 'version': '2'}", "{'theme': 'dark', 'version': '3'}"]
	tgt.assert_distinct_values_of_col("domain_types", "prefs", "public", 
		transform_func=str, expected_distinct_values=expected_prefs_values)

	print("domain_array_types:")
	expected_ssn_list_values = ['{123-45-0001,987-65-0001}', '{123-45-0002,987-65-0002}', '{123-45-0003,987-65-0003}']
	tgt.assert_distinct_values_of_col("domain_array_types", "ssn_list", "public", 
		transform_func=str, expected_distinct_values=expected_ssn_list_values)
	expected_phone_list_values = ['{+91123456701,+91987654301}', '{+91123456702,+91987654302}', '{+91123456703,+91987654303}']
	tgt.assert_distinct_values_of_col("domain_array_types", "phone_list", "public", 
		transform_func=str, expected_distinct_values=expected_phone_list_values)
	expected_name_list_values = ['{"ABC DEF","GHI JKL"}', '{"MNO PQR","STU VWX"}', '{"ABC XYZ","DEF ABC"}']
	tgt.assert_distinct_values_of_col("domain_array_types", "name_list", "public", 
		transform_func=str, expected_distinct_values=expected_name_list_values)

	print("range_types:")
	expected_price_range_values = ['[0.1,5.1)', '[0.2,5.2)', '[0.3,5.3)']
	tgt.assert_distinct_values_of_col("range_types", "price_range_col", "public", 
		transform_func=str, expected_distinct_values=expected_price_range_values)
	expected_discount_range_values = ['[0,1)', '[0.1,1.1)', '[0.2,1.2)']
	tgt.assert_distinct_values_of_col("range_types", "discount_range_col", "public", 
		transform_func=str, expected_distinct_values=expected_discount_range_values)
	# Validate timestamp ranges - timestamps are dynamic so we check the pattern
	actual_ts_ranges = tgt.get_distinct_values_of_column_of_table("range_types", "active_ts_range_col", "public")
	print(f"actual_ts_ranges: {actual_ts_ranges}")
	assert len(actual_ts_ranges) == 3, f"Expected 3 distinct timestamp ranges, got {len(actual_ts_ranges)}"
	ts_range_pattern = r'\["\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+\+\d{2}","\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+\+\d{2}"\)'
	for ts_range in actual_ts_ranges:
		ts_range_str = str(ts_range)
		print(f"{ts_range_str}")
		assert re.match(ts_range_pattern, ts_range_str), f"Timestamp range {ts_range_str} does not match expected pattern"

	print("range_array_types:")
	expected_price_ranges_values = ['{"[1,5)","[10,20)"}']
	tgt.assert_distinct_values_of_col("range_array_types", "price_ranges", "public", 
		transform_func=str, expected_distinct_values=expected_price_ranges_values)
	expected_discount_ranges_values = ['{"[0.5,1)","[1.5,2)"}']
	tgt.assert_distinct_values_of_col("range_array_types", "discount_ranges", "public", 
		transform_func=str, expected_distinct_values=expected_discount_ranges_values)
	# Validate timestamp range arrays - timestamps are dynamic so we check the pattern
	actual_ts_range_arrays = tgt.get_distinct_values_of_column_of_table("range_array_types", "ts_ranges", "public")
	print(f"actual_ts_range_arrays: {actual_ts_range_arrays}")
	assert len(actual_ts_range_arrays) == 3, f"Expected 3 distinct timestamp range arrays, got {len(actual_ts_range_arrays)}"
	ts_range_array_pattern = r'\{"\[\\"\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+\+\d{2}\\",\\"\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+\+\d{2}\\"\)"\}'
	for ts_range_array in actual_ts_range_arrays:
		ts_range_array_str = str(ts_range_array)
		print(f"{ts_range_array_str}")
		assert re.match(ts_range_array_pattern, ts_range_array_str), f"Timestamp range array {ts_range_array_str} does not match expected pattern"

	print("extension_types:")
	expected_hstore_values = ['"key1"=>"1"', '"key2"=>"2"', '"key3"=>"3"']
	tgt.assert_distinct_values_of_col("extension_types", "col_hstore", "public", 
		transform_func=str, expected_distinct_values=expected_hstore_values)
	expected_citext_values = ['text_1', 'text_2', 'text_3']
	tgt.assert_distinct_values_of_col("extension_types", "col_citext", "public", 
		transform_func=str, expected_distinct_values=expected_citext_values)
	# ltree type doesn't support DISTINCT, so we cast to text first
	expected_ltree_values = ['Top.1', 'Top.2', 'Top.3']
	cur = tgt.conn.cursor()
	cur.execute("SELECT DISTINCT col_ltree::text FROM public.extension_types")
	actual_ltree_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_ltree_values: {actual_ltree_values}")
	for ltree_value in actual_ltree_values:
		print(f"{ltree_value}")
		assert ltree_value in expected_ltree_values, f"Unexpected ltree value: {ltree_value}"

	print("extension_arrays:")
	expected_hstore_array_values = [
		'{"\\"key1\\"=>\\"1\\"","\\"value1\\"=>\\"1\\""}',
		'{"\\"key2\\"=>\\"2\\"","\\"value2\\"=>\\"2\\""}',
		'{"\\"key3\\"=>\\"3\\"","\\"value3\\"=>\\"3\\""}'
	]
	tgt.assert_distinct_values_of_col("extension_arrays", "col_hstore", "public", 
		transform_func=str, expected_distinct_values=expected_hstore_array_values)
	expected_citext_array_values = ['{text_1,sample_1}', '{text_2,sample_2}', '{text_3,sample_3}']
	tgt.assert_distinct_values_of_col("extension_arrays", "col_citext", "public", 
		transform_func=str, expected_distinct_values=expected_citext_array_values)
	# ltree array type doesn't support DISTINCT, so we cast to text first
	expected_ltree_array_values = ['{Top.1,Category.1}', '{Top.2,Category.2}', '{Top.3,Category.3}']
	cur = tgt.conn.cursor()
	cur.execute("SELECT DISTINCT col_ltree::text FROM public.extension_arrays")
	actual_ltree_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_ltree_array_values: {actual_ltree_array_values}")
	for ltree_array_value in actual_ltree_array_values:
		print(f"{ltree_array_value}")
		assert ltree_array_value in expected_ltree_array_values, f"Unexpected ltree array value: {ltree_array_value}"

	print("audit_log:")
	expected_involved_employees_values = [
		'{"(Emp_1,active,emp_1@company.com)","(EmpAlt_1,inactive,empalt_1@company.com)"}',
		'{"(Emp_2,active,emp_2@company.com)","(EmpAlt_2,inactive,empalt_2@company.com)"}'
	]
	tgt.assert_distinct_values_of_col("audit_log", "involved_employees", "public", 
		transform_func=str, expected_distinct_values=expected_involved_employees_values)
	expected_affected_clients_values = [
		'{"(Client_1,north,client_1@example.com)","(ClientAlt_1,south,clientalt_1@example.com)"}',
		'{"(Client_2,north,client_2@example.com)","(ClientAlt_2,south,clientalt_2@example.com)"}'
	]
	tgt.assert_distinct_values_of_col("audit_log", "affected_clients", "public", 
		transform_func=str, expected_distinct_values=expected_affected_clients_values)
	# transaction_refs returns Python list format, not PostgreSQL array string format
	expected_transaction_refs_values = [[1, 2, 3], [2, 3, 4]]
	actual_transaction_refs = tgt.get_distinct_values_of_column_of_table("audit_log", "transaction_refs", "public")
	print(f"actual_transaction_refs: {actual_transaction_refs}")
	for transaction_ref in actual_transaction_refs:
		print(f"{transaction_ref}")
		assert transaction_ref in expected_transaction_refs_values, f"Unexpected transaction_refs value: {transaction_ref}"

def YB_specific_checks(tgt):
	yb.verify_colocation(tgt, "postgresql")

if __name__ == "__main__":
	main()
