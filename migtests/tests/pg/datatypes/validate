#!/usr/bin/env python3

import common
import os
import yb
import collections
import re

def main():
	test_type_flags = common.valparser()
	
	migration_completed_checks_yb()

	if test_type_flags['ff_enabled'] == 'true':
		migration_completed_checks_ff()
	
	if test_type_flags['fb_enabled'] == 'true':
		migration_completed_checks_fb()

#=============================================================================

EXPECTED_ROW_COUNT = {
 	'num_types': 3,   
	'datatypes1': 3,  
	'datetime_type': 3, 
	'datatypes2': 3,
	'datetime_type2': 2, 
	'null_and_default' :2,
	'decimal_types': 3,
	'hstore_example': 26,
	'tsvector_table': 3,
	'enum_array_table': 3,
	'composite_types': 2,
	'composite_array_types': 2,
	'domain_types': 3,
	'domain_array_types': 3,
	'range_types': 3,
	'range_array_types': 3,
	'extension_types': 3,
	'extension_arrays': 3,
	'audit_log': 2,
	'numeric_types': 3,
	'numeric_arrays': 3,
	'datetime_types': 3,
	'datetime_arrays': 2,
	'geometry_types': 3,
	'geometry_arrays': 2,
	'network_types': 3,
	'network_arrays': 2,
	'misc_types': 3,
	'misc_arrays': 2
}

EXPECTED_SUM_OF_COLUMN = {
	'num_types': {
		'v1': '32621',
		'v2': '-3380617',
		'v3': '564312385451',
		'v4': '993.999',
		'v5': ['9992334.5429','9992334.54290'],
		'v6': '-$12,000,369.60'
	},
	'decimal_types': {
		'n1':'1865936917203721067473070692042057616523559824435284801786158802063081501757370781516738843414444000.095730002',
		'n2':'167981693608097436.14'
	},
}

EXPECTED_ENUM_VALUES = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
EXPECTED_BYTE_TYPE_VALUES = ['3031303130', '2d61626364', '34343538']

#Due to the large sized source database requirements all tables will come up as colocated for now
EXPECTED_COLOCATION_OF_TABLES = {
	'num_types': 't',   
	'datatypes1': 't',  
	'datetime_type': 't', 
	'datatypes2': 't',
	'datetime_type2': 't', 
	'null_and_default' : 't',
	'decimal_types': 't',
}

def migration_completed_checks_yb():
	print("Running tests on YB")
	yb.run_checks(migration_completed_checks)
	yb.run_checks(YB_specific_checks)

def migration_completed_checks_ff():
	print("Running tests on PG source replica")
	yb.run_checks(migration_completed_checks, db_type="source_replica")

def migration_completed_checks_fb():
	print("Running tests on PG source")
	yb.run_checks(migration_completed_checks, db_type="source")

def migration_completed_checks(tgt):
	table_list = tgt.get_table_names("public")
	print("table_list:", table_list)
	assert len(table_list) == 29

	got_row_count = tgt.row_count_of_all_tables("public")
	for table_name, row_count in EXPECTED_ROW_COUNT.items():
		print(f"table_name: {table_name}, row_count: {got_row_count[table_name]}")
		assert row_count == got_row_count[table_name]

	for table_name, column_names_with_sum in EXPECTED_SUM_OF_COLUMN.items():
		print(f"table_name: {table_name} ---- ")
		for column, sum in column_names_with_sum.items():
			col_sum = tgt.get_sum_of_column_of_table(table_name, column, "public")
			# YB returns .5429 and PG returns .54290. Thus this fails during string comparison
			# TODO Add proper handling for the case
			if column == 'v5' and table_name == 'num_types':
				expected_values = column_names_with_sum[column]
				assert str(col_sum) in expected_values
			else:
				assert str(col_sum) == sum
			print(f"column_name: {column}, sum: {col_sum}")

	distinct_values_enum_types = tgt.get_distinct_values_of_column_of_table("datatypes1", "enum_type", "public")
	print(f"distinct_enum_values:")
	for distinct_value in distinct_values_enum_types:
		print(f"{distinct_value}")
		assert distinct_value.lower() in EXPECTED_ENUM_VALUES

	distinct_values_bool_types = tgt.get_distinct_values_of_column_of_table("datatypes1", "bool_type", "public")
	print(f"distinct_bool_values:")
	for distinct_value in distinct_values_bool_types:
		print(f"{distinct_value}")
		assert distinct_value == 0 or distinct_value == 1

	print(f"distinct_bytea_values:")
	tgt.assert_distinct_values_of_col("datatypes1", "byte_type", "public", 
		transform_func=lambda x: x.hex(), expected_distinct_values=EXPECTED_BYTE_TYPE_VALUES)

	print(f"distinct_json_values:")
	tgt.assert_all_values_of_col("datatypes2", "v1", "public", 
		transform_func=str, expected_values=["{'key1': 'value1', 'key2': 'value2'}", "['a', 'b', 'c', 1, 2, 3]", None])

	print(f"distinct_bit10_values:")
	tgt.assert_distinct_values_of_col("datatypes2", "v2", "public", 
		transform_func=str, expected_distinct_values=['1001100101','0001010101','1001000101'])
	
	print(f"distinct_bit_varying_values:")
	expected_values = ['0001010101','0001010','00101010101010101010101010001010100101010101010101000']
	print(f"expected_values: {expected_values}")
	
	tgt.assert_distinct_values_of_col("datatypes2", "v5", "public", 
		None, expected_distinct_values=expected_values)

	print(f"distinct_int[]_values:")
	tgt.assert_distinct_values_of_col("datatypes2", "v3", "public", 
		expected_distinct_values=[[20000, 14600, 23500, 13250], None])

	print(f"distinct_text[]_values:")
	expected_text_mda_values = [[['â€œFDâ€'], ['act']], [['â€œFDâ€', 'â€œMFâ€'], ['â€œFDâ€', 'â€œPropertyâ€']], [['â€œFDâ€', 'â€œMFâ€'], ['act', 'two']]]
	tgt.assert_distinct_values_of_col("datatypes2", "v4", "public", 
		expected_distinct_values=expected_text_mda_values)

	print(f"distinct_ts_values:")
	tgt.assert_distinct_values_of_col("datetime_type2", "v1", "public", 
		transform_func=str, expected_distinct_values=['2022-11-01 15:55:58.091241', '2022-11-01 15:58:02'])
	
	print("null_and_default:")
	tgt.assert_all_values_of_col("null_and_default", "val", "public", expected_values=["testdefault", None])
	tgt.assert_all_values_of_col("null_and_default", "i", "public", expected_values=[10, None])
	tgt.assert_all_values_of_col("null_and_default", "b", "public", expected_values=[False, None])

	print("hstore_example:")
	expected_hstore_values = [
    '"key1"=>"value1", "key2"=>"value2"',
    '"a\\"b"=>"d\\"a"',
    None,
    '',
    '"key1"=>"value1", "key2"=>"value2"',
    '"key7"=>"value7", "key8"=>"123", "key9"=>"true"',
    '"weight"=>"11.2 ounces", "ISBN-13"=>"978-1449370000", "language"=>"English", "paperback"=>"243", "publisher"=>"postgresqltutorial.com"',
    '"f1"=>"1", "f2"=>"{\\"key1=value1, key2=value2\\"}"',
    '"json_field"=>"{\\"key1=value1, key2={\\"key1=value1, key2=value2\\"}\\"}"',
    '"{\\"key1=value1, key2=value2\\"}"=>"{\\"key1=value1, key2={\\"key1=value1, key2=value2\\"}\\"}"',
    '""=>"emptykey"',
    '"emptyvalue"=>""',
    '"longkey"=>"{}"'.format('x'*10000),
    '"ÐºÐ»ÑŽÑ‡"=>"Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"',
    '"emoji_ðŸ˜€"=>"ðŸ˜ŽðŸ”¥"',
    '"cafÃ©"=>"naÃ¯ve"',
    '"select"=>"statement"',
    '"dup"=>"first"',
    '"key with spaces"=>"value with spaces"',
    '" space_key "=>" space_value "',
    '"key\\"quote"=>"value\\"quote"',
    '"key\'single"=>"value\'single"',
    '"{\\"json_like_key\\":1}"=>"{\\"json_like_value\\":2}"',
	'"\\"{key1:value1,key2:value2}\\""=>"{\\"key1=value1, key2={\\"key1=value1, key2=value2\\"}\\"}"',
	'"\\"{\\"\\"key1\\"\\":\\"\\"value1\\"\\",\\"\\"key2\\"\\":\\"\\"value2\\"\\"}\\""=>"{\\"key1=value1, key2={\\"key1=value1, key2=value2\\"}\\"}"',
	'"key=,=>"=>"value\\\\n\\\\t"'

	]

	tgt.assert_distinct_values_of_col("hstore_example", "data", "public", expected_distinct_values=expected_hstore_values)

	print("tsvector_table:")
	expected_tsvector_titles = ['PostgreSQL Tutorial', 'Advanced SQL', 'Data Migration']
	tgt.assert_distinct_values_of_col("tsvector_table", "title", "public", expected_distinct_values=expected_tsvector_titles)

	print("enum_array_table:")
	# Get actual enum arrays and parse them from string representation to lists
	actual_enum_arrays = tgt.get_distinct_values_of_column_of_table("enum_array_table", "week_days", "public")
	print(f"actual_enum_arrays: {actual_enum_arrays}")
	
	# Parse string representations like '{mon,wed,fri}' into actual lists
	def parse_enum_array_string(array_str):
		if array_str is None:
			return None
		# Remove curly braces and split by comma
		return [item.strip().lower() for item in array_str.strip('{}').split(',')]
	
	parsed_actual_arrays = [parse_enum_array_string(arr) for arr in actual_enum_arrays]
	
	# Expected enum arrays as actual Python lists
	expected_enum_arrays = [['mon', 'wed', 'fri'], ['tue', 'thu'], ['sat', 'sun']]
	
	# Compare actual lists
	for expected_array in expected_enum_arrays:
		assert expected_array in parsed_actual_arrays, f"Expected {expected_array} not found in {parsed_actual_arrays}"

	print("composite_types:")
	expected_composite_types = ['(City1I,"Street 1I",1)', '(City2I,"Street 2I",2)']
	tgt.assert_distinct_values_of_col("composite_types", "address", "public", 
		transform_func=str, expected_distinct_values=expected_composite_types)

	print("composite_array_types:")
	expected_composite_array_types = [
		'{"(CityA1I,\\"StreetA 1I\\",1)","(CityB1I,\\"StreetB 1I\\",2)"}',
		'{"(CityA2I,\\"StreetA 2I\\",2)","(CityB2I,\\"StreetB 2I\\",3)"}'
	]
	tgt.assert_distinct_values_of_col("composite_array_types", "addresses", "public", 
		transform_func=str, expected_distinct_values=expected_composite_array_types)

	print("domain_types:")
	expected_ssn_values = ['001-00-0001', '002-00-0002', '003-00-0003']
	tgt.assert_distinct_values_of_col("domain_types", "ssn", "public", 
		transform_func=str, expected_distinct_values=expected_ssn_values)
	expected_email_values = ['user1@example.com', 'user2@example.com', 'user3@example.com']
	tgt.assert_distinct_values_of_col("domain_types", "email", "public", 
		transform_func=str, expected_distinct_values=expected_email_values)
	expected_rating_values = [1, 2, 3]
	tgt.assert_distinct_values_of_col("domain_types", "rating", "public", 
		expected_distinct_values=expected_rating_values)
	expected_prefs_values = ["{'theme': 'dark', 'version': '1'}", "{'theme': 'dark', 'version': '2'}", "{'theme': 'dark', 'version': '3'}"]
	tgt.assert_distinct_values_of_col("domain_types", "prefs", "public", 
		transform_func=str, expected_distinct_values=expected_prefs_values)

	print("domain_array_types:")
	expected_ssn_list_values = ['{123-45-0001,987-65-0001}', '{123-45-0002,987-65-0002}', '{123-45-0003,987-65-0003}']
	tgt.assert_distinct_values_of_col("domain_array_types", "ssn_list", "public", 
		transform_func=str, expected_distinct_values=expected_ssn_list_values)
	expected_phone_list_values = ['{+91123456701,+91987654301}', '{+91123456702,+91987654302}', '{+91123456703,+91987654303}']
	tgt.assert_distinct_values_of_col("domain_array_types", "phone_list", "public", 
		transform_func=str, expected_distinct_values=expected_phone_list_values)
	expected_name_list_values = ['{"ABC DEF","GHI JKL"}', '{"MNO PQR","STU VWX"}', '{"ABC XYZ","DEF ABC"}']
	tgt.assert_distinct_values_of_col("domain_array_types", "name_list", "public", 
		transform_func=str, expected_distinct_values=expected_name_list_values)

	print("range_types:")
	if os.getenv("BETA_FAST_DATA_EXPORT") == "0" or os.getenv("BETA_FAST_DATA_EXPORT") is None:
		expected_price_range_values = ['[0.1,5.1)', '[0.2,5.2)', '[0.3,5.3)']
	else:
		expected_price_range_values = [None]
	tgt.assert_distinct_values_of_col("range_types", "price_range_col", "public", 
		transform_func=str, expected_distinct_values=expected_price_range_values)
	if os.getenv("BETA_FAST_DATA_EXPORT") == "0" or os.getenv("BETA_FAST_DATA_EXPORT") is None:
		expected_discount_range_values = ['[0,1)', '[0.1,1.1)', '[0.2,1.2)']
	else:
		expected_discount_range_values = [None]
	tgt.assert_distinct_values_of_col("range_types", "discount_range_col", "public", 
		transform_func=str, expected_distinct_values=expected_discount_range_values)
	# Validate timestamp ranges - timestamps are dynamic so we check the pattern
	actual_ts_ranges = tgt.get_distinct_values_of_column_of_table("range_types", "active_ts_range_col", "public")
	print(f"actual_ts_ranges: {actual_ts_ranges}")
	if os.getenv("BETA_FAST_DATA_EXPORT") == "0" or os.getenv("BETA_FAST_DATA_EXPORT") is None:
		assert len(actual_ts_ranges) == 3, f"Expected 3 distinct timestamp ranges, got {len(actual_ts_ranges)}"
		ts_range_pattern = r'\["\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+\+\d{2}","\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+\+\d{2}"\)'
		for ts_range in actual_ts_ranges:
			ts_range_str = str(ts_range)
			print(f"{ts_range_str}")
			assert re.match(ts_range_pattern, ts_range_str), f"Timestamp range {ts_range_str} does not match expected pattern"
	else:
		assert len(actual_ts_ranges) == 1, f"Expected 1 distinct timestamp range, got {len(actual_ts_ranges)}"

	print("range_array_types:")
	expected_price_ranges_values = ['{"[1,5)","[10,20)"}']
	tgt.assert_distinct_values_of_col("range_array_types", "price_ranges", "public", 
		transform_func=str, expected_distinct_values=expected_price_ranges_values)
	expected_discount_ranges_values = ['{"[0.5,1)","[1.5,2)"}']
	tgt.assert_distinct_values_of_col("range_array_types", "discount_ranges", "public", 
		transform_func=str, expected_distinct_values=expected_discount_ranges_values)
	# Validate timestamp range arrays - timestamps are dynamic so we check the pattern
	actual_ts_range_arrays = tgt.get_distinct_values_of_column_of_table("range_array_types", "ts_ranges", "public")
	print(f"actual_ts_range_arrays: {actual_ts_range_arrays}")
	assert len(actual_ts_range_arrays) == 3, f"Expected 3 distinct timestamp range arrays, got {len(actual_ts_range_arrays)}"
	ts_range_array_pattern = r'\{"\[\\"\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+\+\d{2}\\",\\"\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+\+\d{2}\\"\)"\}'
	for ts_range_array in actual_ts_range_arrays:
		ts_range_array_str = str(ts_range_array)
		print(f"{ts_range_array_str}")
		assert re.match(ts_range_array_pattern, ts_range_array_str), f"Timestamp range array {ts_range_array_str} does not match expected pattern"

	print("extension_types:")
	expected_hstore_values = ['"key1"=>"1"', '"key2"=>"2"', '"key3"=>"3"']
	tgt.assert_distinct_values_of_col("extension_types", "col_hstore", "public", 
		transform_func=str, expected_distinct_values=expected_hstore_values)
	expected_citext_values = ['text_1', 'text_2', 'text_3']
	tgt.assert_distinct_values_of_col("extension_types", "col_citext", "public", 
		transform_func=str, expected_distinct_values=expected_citext_values)
	# ltree type doesn't support DISTINCT, so we cast to text first
	expected_ltree_values = ['Top.1', 'Top.2', 'Top.3']
	cur = tgt.conn.cursor()
	cur.execute("SELECT DISTINCT col_ltree::text FROM public.extension_types")
	actual_ltree_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_ltree_values: {actual_ltree_values}")
	for ltree_value in actual_ltree_values:
		print(f"{ltree_value}")
		assert ltree_value in expected_ltree_values, f"Unexpected ltree value: {ltree_value}"

	print("extension_arrays:")
	expected_hstore_array_values = [
		'{"\\"key1\\"=>\\"1\\"","\\"value1\\"=>\\"1\\""}',
		'{"\\"key2\\"=>\\"2\\"","\\"value2\\"=>\\"2\\""}',
		'{"\\"key3\\"=>\\"3\\"","\\"value3\\"=>\\"3\\""}'
	]
	tgt.assert_distinct_values_of_col("extension_arrays", "col_hstore", "public", 
		transform_func=str, expected_distinct_values=expected_hstore_array_values)
	expected_citext_array_values = ['{text_1,sample_1}', '{text_2,sample_2}', '{text_3,sample_3}']
	tgt.assert_distinct_values_of_col("extension_arrays", "col_citext", "public", 
		transform_func=str, expected_distinct_values=expected_citext_array_values)
	# ltree array type doesn't support DISTINCT, so we cast to text first
	expected_ltree_array_values = ['{Top.1,Category.1}', '{Top.2,Category.2}', '{Top.3,Category.3}']
	cur = tgt.conn.cursor()
	cur.execute("SELECT DISTINCT col_ltree::text FROM public.extension_arrays")
	actual_ltree_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_ltree_array_values: {actual_ltree_array_values}")
	for ltree_array_value in actual_ltree_array_values:
		print(f"{ltree_array_value}")
		assert ltree_array_value in expected_ltree_array_values, f"Unexpected ltree array value: {ltree_array_value}"

	print("audit_log:")
	expected_involved_employees_values = [
		'{"(Emp_1,active,emp_1@company.com)","(EmpAlt_1,inactive,empalt_1@company.com)"}',
		'{"(Emp_2,active,emp_2@company.com)","(EmpAlt_2,inactive,empalt_2@company.com)"}'
	]
	tgt.assert_distinct_values_of_col("audit_log", "involved_employees", "public", 
		transform_func=str, expected_distinct_values=expected_involved_employees_values)
	expected_affected_clients_values = [
		'{"(Client_1,north,client_1@example.com)","(ClientAlt_1,south,clientalt_1@example.com)"}',
		'{"(Client_2,north,client_2@example.com)","(ClientAlt_2,south,clientalt_2@example.com)"}'
	]
	tgt.assert_distinct_values_of_col("audit_log", "affected_clients", "public", 
		transform_func=str, expected_distinct_values=expected_affected_clients_values)
	# transaction_refs returns Python list format, not PostgreSQL array string format
	expected_transaction_refs_values = [[1, 2, 3], [2, 3, 4]]
	actual_transaction_refs = tgt.get_distinct_values_of_column_of_table("audit_log", "transaction_refs", "public")
	print(f"actual_transaction_refs: {actual_transaction_refs}")
	for transaction_ref in actual_transaction_refs:
		print(f"{transaction_ref}")
		assert transaction_ref in expected_transaction_refs_values, f"Unexpected transaction_refs value: {transaction_ref}"

	print("numeric_types:")
	expected_real_values = [1.1, 2.1, 3.1]
	tgt.assert_distinct_values_of_col("numeric_types", "real_col", "public", 
		expected_distinct_values=expected_real_values)
	expected_double_values = [1.2, 2.2, 3.2]
	tgt.assert_distinct_values_of_col("numeric_types", "double_col", "public", 
		expected_distinct_values=expected_double_values)
	expected_small_serial_values = [1, 2, 3]
	tgt.assert_distinct_values_of_col("numeric_types", "small_serial_col", "public", 
		expected_distinct_values=expected_small_serial_values)
	expected_big_serial_values = [1, 2, 3]
	tgt.assert_distinct_values_of_col("numeric_types", "big_serial_col", "public", 
		expected_distinct_values=expected_big_serial_values)

	print("numeric_arrays:")
	expected_real_array_values = [[1.1,1.2,1.3], [2.1,2.2,2.3], [3.1,3.2,3.3]]
	tgt.assert_distinct_values_of_col("numeric_arrays", "real_col", "public", 
		expected_distinct_values=expected_real_array_values)
	expected_double_array_values = [[1.1,1.2,1.3], [2.1,2.2,2.3], [3.1,3.2,3.3]]
	tgt.assert_distinct_values_of_col("numeric_arrays", "double_col", "public", 
		expected_distinct_values=expected_double_array_values)

	print("datetime_types:")
	# timestamptz values are dynamic, so we check the pattern
	actual_timestamptz_values = tgt.get_distinct_values_of_column_of_table("datetime_types", "timestamptz_col", "public")
	print(f"actual_timestamptz_values: {actual_timestamptz_values}")
	assert len(actual_timestamptz_values) == 3, f"Expected 3 distinct timestamptz values, got {len(actual_timestamptz_values)}"
	timestamptz_pattern = r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}[\+\-]\d{2}'
	for timestamptz_value in actual_timestamptz_values:
		timestamptz_str = str(timestamptz_value)
		print(f"{timestamptz_str}")
		assert re.search(timestamptz_pattern, timestamptz_str), f"Timestamptz value {timestamptz_str} does not match expected pattern"
	if os.getenv("BETA_FAST_DATA_EXPORT") == "0" or os.getenv("BETA_FAST_DATA_EXPORT") is None:
		expected_timetz_values = ['09:30:15+05:30', '23:59:59+02:00', '06:45:00-03:00']
		tgt.assert_distinct_values_of_col("datetime_types", "timetz_col", "public", 
			transform_func=str, expected_distinct_values=expected_timetz_values)
	expected_interval_values = ['0:17:00', '5 days, 0:00:00', '9:00:00']
	tgt.assert_distinct_values_of_col("datetime_types", "interval_col", "public", 
		transform_func=str, expected_distinct_values=expected_interval_values)

	print("datetime_arrays:")
	# timestamptz arrays are dynamic, so we check the pattern
	actual_timestamptz_arrays = tgt.get_distinct_values_of_column_of_table("datetime_arrays", "timestamptz_col", "public")
	print(f"actual_timestamptz_arrays: {actual_timestamptz_arrays}")
	assert len(actual_timestamptz_arrays) == 2, f"Expected 2 distinct timestamptz arrays, got {len(actual_timestamptz_arrays)}"
	expected_interval_array_values = [
		'[datetime.timedelta(seconds=600), datetime.timedelta(seconds=10800), datetime.timedelta(days=2)]',
		'[datetime.timedelta(days=30), datetime.timedelta(days=14), datetime.timedelta(seconds=2400)]'
	]
	tgt.assert_distinct_values_of_col("datetime_arrays", "interval_col", "public", 
		transform_func=str, expected_distinct_values=expected_interval_array_values)

	if os.getenv("BETA_FAST_DATA_EXPORT") == "0" or os.getenv("BETA_FAST_DATA_EXPORT") is None:
		print("geometry_types:")
		# Geometry types don't support DISTINCT, so we cast to text first
		cur = tgt.conn.cursor()
		
		expected_point_values = ['(1,2)', '(5,6)', '(-2,4)']
		cur.execute("SELECT DISTINCT point_col::text FROM public.geometry_types")
		actual_point_values = [str(value[0]) for value in cur.fetchall()]
		print(f"actual_point_values: {actual_point_values}")
		for point_value in actual_point_values:
			print(f"{point_value}")
			assert point_value in expected_point_values, f"Unexpected point value: {point_value}"
		
		expected_line_values = ['{1,-1,0}', '{1,-1,2}', '{0.166666666666667,-1,1.66666666666667}']
		cur.execute("SELECT DISTINCT line_col::text FROM public.geometry_types")
		actual_line_values = [str(value[0]) for value in cur.fetchall()]
		print(f"actual_line_values: {actual_line_values}")
		for line_value in actual_line_values:
			print(f"{line_value}")
			assert line_value in expected_line_values, f"Unexpected line value: {line_value}"
		
		expected_lseg_values = ['[(1,1),(4,4)]', '[(2,3),(7,9)]', '[(0,0),(10,10)]']
		cur.execute("SELECT DISTINCT lseg_col::text FROM public.geometry_types")
		actual_lseg_values = [str(value[0]) for value in cur.fetchall()]
		print(f"actual_lseg_values: {actual_lseg_values}")
		for lseg_value in actual_lseg_values:
			print(f"{lseg_value}")
			assert lseg_value in expected_lseg_values, f"Unexpected lseg value: {lseg_value}"
		
		expected_box_values = ['(3,2),(0,0)', '(4,5),(1,1)', '(1,1),(-1,-1)']
		cur.execute("SELECT DISTINCT box_col::text FROM public.geometry_types")
		actual_box_values = [str(value[0]) for value in cur.fetchall()]
		print(f"actual_box_values: {actual_box_values}")
		for box_value in actual_box_values:
			print(f"{box_value}")
			assert box_value in expected_box_values, f"Unexpected box value: {box_value}"
		
		expected_path_values = ['[(0,0),(1,2),(2,1)]', '((1,1),(2,3),(4,1))', '[(3,3),(6,6),(9,3)]']
		cur.execute("SELECT DISTINCT path_col::text FROM public.geometry_types")
		actual_path_values = [str(value[0]) for value in cur.fetchall()]
		print(f"actual_path_values: {actual_path_values}")
		for path_value in actual_path_values:
			print(f"{path_value}")
			assert path_value in expected_path_values, f"Unexpected path value: {path_value}"
		
		expected_polygon_values = ['((0,0),(2,0),(2,2),(0,2))', '((1,1),(4,1),(4,4),(1,4))', '((2,2),(6,2),(6,6),(2,6))']
		cur.execute("SELECT DISTINCT polygon_col::text FROM public.geometry_types")
		actual_polygon_values = [str(value[0]) for value in cur.fetchall()]
		print(f"actual_polygon_values: {actual_polygon_values}")
		for polygon_value in actual_polygon_values:
			print(f"{polygon_value}")
			assert polygon_value in expected_polygon_values, f"Unexpected polygon value: {polygon_value}"
		
		expected_circle_values = ['<(3,3),2>', '<(0,0),5>', '<(-3,1),4>']
		cur.execute("SELECT DISTINCT circle_col::text FROM public.geometry_types")
		actual_circle_values = [str(value[0]) for value in cur.fetchall()]
		print(f"actual_circle_values: {actual_circle_values}")
		for circle_value in actual_circle_values:
			print(f"{circle_value}")
			assert circle_value in expected_circle_values, f"Unexpected circle value: {circle_value}"

	print("geometry_arrays:")
	# Geometry array types don't support DISTINCT, so we cast to text first
	cur = tgt.conn.cursor()
	
	expected_point_array_values = [
		'{"(1,1)","(2,2)","(3,3)"}',
		'{"(4,4)","(5,5)"}'
	]
	cur.execute("SELECT DISTINCT point_col::text FROM public.geometry_arrays")
	actual_point_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_point_array_values: {actual_point_array_values}")
	for point_array_value in actual_point_array_values:
		print(f"{point_array_value}")
		assert point_array_value in expected_point_array_values, f"Unexpected point array value: {point_array_value}"
	
	expected_line_array_values = [
		'{"{1,-1,0}","{1,-1,0}"}',
		'{"{1,-1,0}"}'
	]
	cur.execute("SELECT DISTINCT line_col::text FROM public.geometry_arrays")
	actual_line_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_line_array_values: {actual_line_array_values}")
	for line_array_value in actual_line_array_values:
		print(f"{line_array_value}")
		assert line_array_value in expected_line_array_values, f"Unexpected line array value: {line_array_value}"
	
	expected_lseg_array_values = [
		'{"[(0,0),(5,5)]","[(1,2),(3,4)]"}',
		'{"[(5,1),(6,9)]"}'
	]
	cur.execute("SELECT DISTINCT lseg_col::text FROM public.geometry_arrays")
	actual_lseg_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_lseg_array_values: {actual_lseg_array_values}")
	for lseg_array_value in actual_lseg_array_values:
		print(f"{lseg_array_value}")
		assert lseg_array_value in expected_lseg_array_values, f"Unexpected lseg array value: {lseg_array_value}"
	
	expected_box_array_values = [
		'{(2,2),(0,0);(5,3),(1,1)}',
		'{(8,8),(2,2)}'
	]
	cur.execute("SELECT DISTINCT box_col::text FROM public.geometry_arrays")
	actual_box_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_box_array_values: {actual_box_array_values}")
	for box_array_value in actual_box_array_values:
		print(f"{box_array_value}")
		assert box_array_value in expected_box_array_values, f"Unexpected box array value: {box_array_value}"
	
	expected_path_array_values = [
		'{"[(0,0),(1,2),(3,1)]","[(2,2),(3,5)]"}',
		'{"[(1,1),(2,4),(5,2)]"}'
	]
	cur.execute("SELECT DISTINCT path_col::text FROM public.geometry_arrays")
	actual_path_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_path_array_values: {actual_path_array_values}")
	for path_array_value in actual_path_array_values:
		print(f"{path_array_value}")
		assert path_array_value in expected_path_array_values, f"Unexpected path array value: {path_array_value}"
	
	expected_polygon_array_values = [
		'{"((0,0),(3,0),(3,3),(0,3))","((1,1),(4,1),(4,4),(1,4))"}',
		'{"((2,2),(6,2),(6,6),(2,6))"}'
	]
	cur.execute("SELECT DISTINCT polygon_col::text FROM public.geometry_arrays")
	actual_polygon_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_polygon_array_values: {actual_polygon_array_values}")
	for polygon_array_value in actual_polygon_array_values:
		print(f"{polygon_array_value}")
		assert polygon_array_value in expected_polygon_array_values, f"Unexpected polygon array value: {polygon_array_value}"
	
	expected_circle_array_values = [
		'{"<(1,1),2>","<(3,3),4>"}',
		'{"<(0,0),1>","<(2,5),3>"}'
	]
	cur.execute("SELECT DISTINCT circle_col::text FROM public.geometry_arrays")
	actual_circle_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_circle_array_values: {actual_circle_array_values}")
	for circle_array_value in actual_circle_array_values:
		print(f"{circle_array_value}")
		assert circle_array_value in expected_circle_array_values, f"Unexpected circle array value: {circle_array_value}"

	print("network_types:")
	expected_cidr_values = ['10.0.0.0/8', '172.16.0.0/12', '192.168.100.0/24']
	tgt.assert_distinct_values_of_col("network_types", "cidr_col", "public", 
		transform_func=str, expected_distinct_values=expected_cidr_values)
	expected_inet_values = ['10.1.2.3', '172.16.5.9', '192.168.100.42']
	tgt.assert_distinct_values_of_col("network_types", "inet_col", "public", 
		transform_func=str, expected_distinct_values=expected_inet_values)
	expected_macaddr_values = ['aa:bb:cc:dd:ee:ff', '00:11:22:33:44:55', 'de:ad:be:ef:00:01']
	tgt.assert_distinct_values_of_col("network_types", "macaddr_col", "public", 
		transform_func=str, expected_distinct_values=expected_macaddr_values)
	expected_macaddr8_values = ['aa:bb:cc:ff:fe:dd:ee:ff', '00:11:22:ff:fe:33:44:55', 'de:ad:be:ff:fe:ef:00:01']
	tgt.assert_distinct_values_of_col("network_types", "macaddr8_col", "public", 
		transform_func=str, expected_distinct_values=expected_macaddr8_values)

	print("network_arrays:")
	expected_cidr_array_values = [
		"['10.0.0.0/8', '10.10.0.0/16', '10.20.30.0/24']",
		"['172.16.0.0/12', '172.16.5.9/32', '192.168.100.0/24']"
	]
	tgt.assert_distinct_values_of_col("network_arrays", "cidr_col", "public", 
		transform_func=str, expected_distinct_values=expected_cidr_array_values)
	expected_inet_array_values = [
		"['10.0.0.1', '10.10.0.5', '10.20.30.99']",
		"['172.16.5.9', '192.168.100.42', '192.168.100.42']"
	]
	tgt.assert_distinct_values_of_col("network_arrays", "inet_col", "public", 
		transform_func=str, expected_distinct_values=expected_inet_array_values)
	expected_macaddr_array_values = [
		"['aa:bb:cc:11:22:33', 'aa:bb:cc:44:55:66', 'aa:bb:cc:77:88:99']",
		"['00:11:22:33:44:55', 'de:ad:be:ef:00:01', 'de:ad:be:ef:00:01']"
	]
	tgt.assert_distinct_values_of_col("network_arrays", "macaddr_col", "public", 
		transform_func=str, expected_distinct_values=expected_macaddr_array_values)
	expected_macaddr8_array_values = [
		"{aa:bb:cc:ff:fe:11:22:33,aa:bb:cc:ff:fe:44:55:66,aa:bb:cc:ff:fe:77:88:99}",
		"{00:11:22:ff:fe:33:44:55,de:ad:be:ff:fe:ef:00:01,de:ad:be:ff:fe:ef:00:01}"
	]
	tgt.assert_distinct_values_of_col("network_arrays", "macaddr8_col", "public", 
		transform_func=str, expected_distinct_values=expected_macaddr8_array_values)

	if os.getenv("BETA_FAST_DATA_EXPORT") == "0" or os.getenv("BETA_FAST_DATA_EXPORT") is None:
		print("misc_types:")
		expected_pg_lsn_values = ['0/16B6C50', '0/1ABCD00', '0/2FF0010']
		tgt.assert_distinct_values_of_col("misc_types", "pg_lsn_col", "public", 
			transform_func=str, expected_distinct_values=expected_pg_lsn_values)
		# txid_snapshot type doesn't support DISTINCT, so we cast to text first
		expected_txid_snapshot_values = ['100:105:101', '200:210:205', '50:52:51']
		cur = tgt.conn.cursor()
		cur.execute("SELECT DISTINCT txid_snapshot_col::text FROM public.misc_types")
		actual_txid_snapshot_values = [str(value[0]) for value in cur.fetchall()]
		print(f"actual_txid_snapshot_values: {actual_txid_snapshot_values}")
		for txid_snapshot_value in actual_txid_snapshot_values:
			print(f"{txid_snapshot_value}")
			assert txid_snapshot_value in expected_txid_snapshot_values, f"Unexpected txid_snapshot value: {txid_snapshot_value}"

	print("misc_arrays:")
	expected_pg_lsn_array_values = [
		'{0/16B6C50,0/1FFAA00,0/ABC1234}',
		'{0/3000000,0/4000001,0/5000002}'
	]
	tgt.assert_distinct_values_of_col("misc_arrays", "pg_lsn_col", "public", 
		transform_func=str, expected_distinct_values=expected_pg_lsn_array_values)
	# txid_snapshot array type doesn't support DISTINCT, so we cast to text first
	expected_txid_snapshot_array_values = [
		'{10:20:15,100:105:101,88:90:89}',
		'{500:505:503,1000:1010:1005,42:45:44}'
	]
	cur.execute("SELECT DISTINCT txid_snapshot_col::text FROM public.misc_arrays")
	actual_txid_snapshot_array_values = [str(value[0]) for value in cur.fetchall()]
	print(f"actual_txid_snapshot_array_values: {actual_txid_snapshot_array_values}")
	for txid_snapshot_array_value in actual_txid_snapshot_array_values:
		print(f"{txid_snapshot_array_value}")
		assert txid_snapshot_array_value in expected_txid_snapshot_array_values, f"Unexpected txid_snapshot array value: {txid_snapshot_array_value}"

def YB_specific_checks(tgt):
	yb.verify_colocation(tgt, "postgresql")

if __name__ == "__main__":
	main()
