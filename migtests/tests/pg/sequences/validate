#!/usr/bin/env python3

import yb

def main():
	yb.run_checks(migration_completed_checks)


#=============================================================================

EXPECTED_ROW_COUNT = {}
EXPECTED_ROW_COUNT['public'] = {
	'sequence_check1': 2,
	'sequence_check2': 7,
	'sequence_check3': 3,
    'multiple_identity_columns': 2,
    'multiple_serial_columns': 2,
    'foo': 2,
    'bar': 2,
    'foo_bar': 2,
}

EXPECTED_ROW_COUNT['schema1'] = {
	'sequence_check1': 1,
	'sequence_check2': 6,
	'sequence_check3': 2,
    'multiple_identity_columns': 2,
    'multiple_serial_columns': 2,
}

EXPECTED_ROW_COUNT['schema2'] = {
    'foo': 2,
    'bar': 2,
}

EXPECTED_ROW_COUNT['schema3'] = {
    'foo': 2,
}

EXPECTED_ROW_COUNT['schema4'] = {
    'bar': 2,
}

EXPECTED_TABLE_SUM = {}
EXPECTED_TABLE_SUM['public'] = {
	'sequence_check1': 3,
	'sequence_check2': 28,
	'sequence_check3': 6,
    'multiple_identity_columns': 3,
    'multiple_serial_columns': 3,
    'foo': 4,
    'bar': 6,
    'foo_bar': 4, # two columns with same sequence used
}

EXPECTED_TABLE_SUM['schema1'] = {
	'sequence_check1': 1,
	'sequence_check2': 21,
	'sequence_check3': 3,
    'multiple_identity_columns': 3,
    'multiple_serial_columns': 3,
}

EXPECTED_TABLE_SUM['schema2'] = {
    'foo': 4,
    'bar': 6,
}

EXPECTED_TABLE_SUM['schema3'] = {
    'foo': 4,
}

EXPECTED_TABLE_SUM['schema4'] = {
    'bar': 6,
}

NUM_TABLES = {
    'public': 8,
    'schema1': 5,
    'schema2': 2,
    'schema3': 1,
    'schema4': 1
}

NUM_SEQUENCES = {
    'public': 4+2, # 2 are implicit because of serial/generated columns
    'schema1': 1+3, # 3 are implicit because of serial/generated columns
    'schema2': 1,
    'schema3': 1,
    'schema4': 0
}

def migration_completed_checks_per_schema(tgt, schema):
    print("check for schema: ", schema)
    table_list = tgt.count_tables(schema)
    print(f"actual table_list: {table_list}, expected num_tables: {NUM_TABLES[schema]}")
    assert table_list == NUM_TABLES[schema]
    
    num_sequences = tgt.count_sequences(schema)
    print(f"actual number_sequences: {num_sequences}, expected num_sequences: {NUM_SEQUENCES[schema]}")
    assert num_sequences == NUM_SEQUENCES[schema]
    
    got_row_count = tgt.row_count_of_all_tables(schema)
    for table_name, row_count in EXPECTED_ROW_COUNT[schema].items():
        print(f"table_name: {table_name}, got_row_count: {got_row_count[table_name]}, expected_row_count: {row_count}")
        assert row_count == got_row_count[table_name]
        
    for table_name, sum_column_values in EXPECTED_TABLE_SUM[schema].items():
        got_sum_column_values = tgt.get_sum_of_column_of_table(table_name, "id", schema)
        print(f"table_name: {table_name}, got_sum_column_values: {got_sum_column_values}, expected_sum_column_values: {sum_column_values}")
        assert sum_column_values == got_sum_column_values
    
    # this validation check has been as added for issue - https://github.com/yugabyte/yb-voyager/issues/632
    SEQUENCE_NAMES = ["sequence_check1_id_seq", "sequence_check2_id_seq", "sequence_check3_id_seq", "schema1.sequence_check1_id_seq", 
                        "schema1.sequence_check2_id_seq", "schema1.sequence_check3_id_seq", "multiple_identity_columns_id_seq", 
                        "multiple_serial_columns_id_seq", "schema1.multiple_identity_columns_id_seq", "schema1.multiple_serial_columns_id_seq"]
    SEQUENCE_OWNER_COLUMNS = ["sequence_check1.id", "sequence_check2.id", "sequence_check3.id", "schema1.sequence_check1.id", 
                                "schema1.sequence_check2.id", "schema1.sequence_check3.id", "multiple_identity_columns.id",
                                "multiple_serial_columns.id", "schema1.multiple_identity_columns.id", "schema1.multiple_serial_columns.id"]
    
    for i in range(len(SEQUENCE_NAMES)):
        FETCH_SEQUENCE_OWNER_QUERY = f"""SELECT CONCAT(d.refobjid::regclass, '.', a.attname) AS owner_column
        FROM   pg_depend    d
        JOIN   pg_attribute a ON a.attrelid = d.refobjid
        AND a.attnum   = d.refobjsubid
        WHERE  d.objid = '{SEQUENCE_NAMES[i]}'::regclass
        AND    d.refobjsubid > 0
        AND    d.classid = 'pg_class'::regclass"""
        FETCHED_SEQUENCE_OWNER_COLUMN = tgt.execute_query(FETCH_SEQUENCE_OWNER_QUERY)
        
        print(f"fetched owner column of sequence {SEQUENCE_NAMES[i]} is: {SEQUENCE_OWNER_COLUMNS[i]}, expected owner: {FETCHED_SEQUENCE_OWNER_COLUMN}")
        assert FETCHED_SEQUENCE_OWNER_COLUMN == SEQUENCE_OWNER_COLUMNS[i]

def migration_completed_checks_for_sequences_per_schema(tgt, schema):
    INSERT_SEQUENCE_QUERY = f"insert into {schema}.sequence_check3 (name) values ('Yugabyte');"
    insert_query_chk_error = tgt.run_query_and_chk_error(INSERT_SEQUENCE_QUERY, None)
    print(f"insert query returned for {schema}.sequence_check3 - {insert_query_chk_error}")
    assert insert_query_chk_error == False
    
    
    SELECT_ID_QUERY = f"select id from {schema}.sequence_check3 where name = 'Yugabyte';"
    id_returned = tgt.execute_query(SELECT_ID_QUERY)
    expected_id = EXPECTED_ROW_COUNT[schema]['sequence_check3'] + 1
    print(f"for sequence_check3, Id returned- {id_returned} and expected id - {expected_id}")
    assert id_returned == expected_id

def migration_completed_checks(tgt):
    migration_completed_checks_per_schema(tgt, 'public')
    migration_completed_checks_per_schema(tgt, 'schema1')
    migration_completed_checks_per_schema(tgt, 'schema2')
    migration_completed_checks_per_schema(tgt, 'schema3')
    migration_completed_checks_per_schema(tgt, 'schema4')

    migration_completed_checks_for_sequences_per_schema(tgt, 'public')
    migration_completed_checks_for_sequences_per_schema(tgt, 'schema1')

if __name__ == "__main__":
	main()